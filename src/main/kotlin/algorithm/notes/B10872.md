# [팩토리얼](https://www.acmicpc.net/problem/10872)

- 2025.12.03

## 문제

0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에 정수 N(0 ≤ N ≤ 12)이 주어진다.

## 출력

첫째 줄에 N!을 출력한다.

예제 입력 1: `10`
예제 출력 1: `3628800`

예제 입력 2: `0`
예제 출력 2: `1`

---

## 내 풀이 과정

### 1단계: 문제 이해
팩토리얼의 정의를 먼저 파악했습니다. N! = N × (N-1) × (N-2) × ... × 2 × 1이며, 특수한 경우로 0! = 1임을 확인했습니다. `readln()`으로 입력을 받고, `repeat`와 조건문을 활용할 수 있다는 것을 알고 있었습니다.

### 2단계: 초기 시도

```kotlin
fun main() {
    val N = readln().toInt()

    repeat(N) {
        val factorial = N-1
        if(factorial < N) {
            return 
        }
    }
}
```

처음에는 `repeat`를 사용하여 N번 반복하고, `factorial = N-1`로 값을 계산하려 했습니다. 그러나 이 방식에는 여러 문제가 있었습니다. 첫째, `factorial`이 매 반복마다 같은 값(N-1)으로 계산되었고, 둘째, 곱셈 연산이 어디에도 없었으며, 셋째, `return`으로 첫 반복에서 바로 종료되어 버렸습니다.

### 3단계: 곱셈 추가 시도

```kotlin
fun main() {
    val N = readln().toInt()

    repeat(N) {
        val factorial = N-1
        if(factorial < N) {
           val p = factorial*N
        }
    }
}
```

곱셈을 추가했지만 여전히 문제가 남아있었습니다. `p` 변수가 반복문 내부에서만 존재하여 다음 반복에서 이전 계산 결과를 사용할 수 없었고, `factorial`이 여전히 매 반복마다 같은 값이었습니다. 또한 계산 결과를 출력하는 부분도 없었습니다.

### 4단계: for문 도입 시도

```kotlin
fun main() {
    val N = readln().toInt()

    repeat(N) {
        val factorial = N-1
        for (i in 1..N){
            val p = factorial * N
        }
    }
}
```

`for (i in 1..N)`을 추가하여 1부터 N까지의 숫자를 얻으려 했습니다. 하지만 `repeat`와 `for`를 중복으로 사용하고 있었고, 정작 반복 변수 `i`는 계산에 활용하지 않았습니다. 또한 `p` 변수가 여전히 for문 내부에만 존재하여 값이 누적되지 않았습니다.

### 5단계: 구조 단순화 시도

```kotlin
fun main() {
    val N = readln().toInt()

    val factorial = N-1
    for (i in 1..N){
        val result = factorial * N
    }
}
```

`repeat`를 제거하고 `for`문만 남겼습니다. 그러나 여전히 핵심적인 문제들이 남아있었습니다. `result` 변수가 for문 내부에 선언되어 매 반복마다 새로 만들어지고 사라졌으며, `factorial = N-1`은 고정된 값이었고, for문의 반복 변수 `i`를 실제 계산에 사용하지 않았습니다.

### 6단계: 핵심 개념 파악
여러 시행착오를 거치며 팩토리얼 계산에 필요한 핵심 요소들을 정리했습니다. 첫째, 결과를 누적할 변수가 반복문 외부에 필요합니다. 둘째, 1부터 N까지의 모든 수를 차례로 곱해야 합니다. 셋째, 초기값은 1이어야 합니다(곱셈의 항등원). 넷째, for문의 반복 변수 `i`를 실제 곱셈에 사용해야 합니다.

### 7단계: 최종 해결 (반복문 방식)

```kotlin
fun main() {
    val n = readln().toInt()
    
    var result = 1  // 결과를 누적할 변수, 반복문 밖에 선언
    for (i in 1..n) {  // 1부터 n까지 반복
        result = result * i  // 이전 결과에 현재 숫자를 곱함
    }
    
    println(result)
}
```

반복문을 사용한 최종 해결 방식입니다. `result` 변수를 for문 외부에 `var`로 선언하여 값이 계속 누적되도록 했고, `for (i in 1..n)`을 통해 1부터 n까지의 모든 수를 순회하며 `i` 변수를 직접 곱셈에 사용했습니다. 마지막으로 `println`으로 결과를 출력했습니다.

### 8단계: 재귀 방식 학습

```kotlin
fun main() {
    val n = readln().toInt()
    println(factorial(n))
}

fun factorial(n: Int): Int {
    if (n == 0 || n == 1) {
        return 1  // 종료 조건: 0!과 1!은 1
    }
    return n * factorial(n - 1)  // n! = n × (n-1)!
}
```

재귀 방식은 팩토리얼의 수학적 정의를 그대로 코드로 옮긴 형태입니다. 함수가 자기 자신을 호출하며 문제를 점점 작은 단위로 쪼개고, 종료 조건에 도달하면 값을 반환하며 다시 올라옵니다. 반복문 방식과는 완전히 다른 사고방식이지만 같은 결과를 냅니다.

### 배운 점
변수의 스코프와 생명주기가 얼마나 중요한지 체감했습니다. 반복문 내부에서 선언한 변수는 매 반복마다 초기화되므로, 값을 누적하려면 반복문 외부에 선언해야 합니다. 또한 `val`과 `var`의 차이, 그리고 반복 변수를 실제로 활용하는 방법을 배웠습니다. 마지막으로 같은 문제도 반복문과 재귀라는 서로 다른 사고방식으로 접근할 수 있음을 알게 되었습니다.
