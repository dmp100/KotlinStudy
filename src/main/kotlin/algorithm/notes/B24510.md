# [B24510](/Users/seong-gyuhyeon/Documents/GitHub/KotlintoTop/src/main/kotlin/algorithm/B24510.kt) - 백준 24510

* 날짜: 2025-11-12
* 주제: For, While, 시간복잡도


## 📖 백준 온라인 저지: 24510번 - 시간복잡도를 배운 도도

-----

### **문제**

도도는 이번 신촌캠프에서 시간복잡도의 개념에 대해 배웠다. 하지만 듣다가 졸려서 자버린 결과 오개념을 가져 버렸는데, 바로 **반복문의 개수로만 시간복잡도를 판단**한다는 것이다.

시간복잡도를 판단하기 위해 도도는 같은 줄에 몇 개의 반복문이 있는지 궁금해졌다. 도도가 반복문으로 생각하는 코드는 **`for`**, \*\*`while`\*\*이다.

도도를 위해 같은 줄에 있는 반복문의 **최대 개수**를 구하는 프로그램을 작성해보자.

| 항목 | 내용 |
| :--- | :--- |
| **시간 제한** | 1 초 (추가 시간 없음) |
| **메모리 제한** | 1024 MB (추가 메모리 없음) |
| **제출/정답/맞힌 사람** | 2032 / 1284 / 1072 |
| **정답 비율** | 63.696% |

-----

### **입력**

첫째 줄에 코드의 줄 개수 $C$ $(1 \leq C \leq 100)$가 주어진다.
둘째 줄부터 $C$개의 줄에 걸쳐 코드가 입력된다. 입력으로 주어지는 코드는 모두 **알파벳 소문자**이다. 각 줄은 $10\,000$자를 넘지 않는다.

-----

### **출력**

첫째 줄에 같은 줄에 있는 반복문의 **최대 개수**를 출력한다.

-----

### **예제 입력 1**

```
3
for
forwhileforfor
forwhileannsds
```

### **예제 출력 1**

```
4
```

> **설명:** $2$번째 줄에서 반복문이 $4$번 등장한다.

-----

### **예제 입력 2**

```
2
asdsdasds
dsdsdss
```

### **예제 출력 2**

```
0
```

> **설명:** 모든 줄에서 반복문이 등장하지 않는다.

-----

### **출처 및 정보**

* **출처:** Camp \> ICPC Sinchon Algorithm Camp \> 2022 ICPC Sinchon Winter Algorithm Camp Contest \> 초급 A번
* **알고리즘 분류:** 보기
* **Baekjoon Online Judge 문제 링크:** [https://www.acmicpc.net/problem/24510](https://www.acmicpc.net/problem/24510)

---

# 0. 해결해야하는 문제가 뭘까 ? (Problem Definition)

사실 문제부터 이해가 안 갔음

같은 줄에 몇 개의 반복문이 있는지 궁금해졌다. <- 이 문장 자체가 그냥 이해가 안갔음

For나 While로 출력하라는건가 ?, 반복할 수 있는 문자의 최대개수를 구하라는건가 ?

근데 알고보니 그냥 `for`나 `while`이라는 단어가 한줄에 몇개 있냐를 얘기하는 거 였음ㅋㅋ;


> 결론 : `for`나 `while` 이라는 단어가 몇개있는지 세서 그 단어들이 제일 많이 있는 문장을 출력하라


# 1. 어떤것을 주고 받아야 할까 ? (I.O)

- 무엇을 알려줘야할까 ?
>1. 첫째줄 : 코드가 몇 줄 정도 될지 입력하라고 한다, 몇 줄 문장을 적을 것인지 알려줘야 할 것 같다.

   (예로 들면 3문장 이면 3을 입력하라는 것 같다, 1줄과 100줄사이에서 정의해야 할 것 같다.)
```
3
```

>2. 둘째줄 : 입력한 줄에 맞춰서 문장을 쓰면 될 것 같다.

(알파벳 소문자만 나오도록 해야한다. 각 줄은 10000자를 넘지 않아야한다.)

```
for
forwhileforfor
forwhileannsds
```

- 무엇을 받아야할까 ?
> 3. 두번째, 세번째....C 번째 줄까지 적은 문장에서, `for`와 `while` 단어의 최대개수를 출력해야한다..
```
4 // for while for for 라서 제일많음
```

# 2. 어떤 과정을 거쳐야 할까 (Algorithm) ?

여러 줄을 받아야 할 것 같은데, 일단 내 머리로 떠오르는거는
정수로 몇줄 받을지 입력받고 ?

그다음 문자열로 문장을 쓰도록 받게 해줘야할 것 같다.

다음은 뭐해야하냐

모르겠음 

문자열인데 `realn().toInt()`로 하면 문자로 못받나 ? 

GPT 형님한테 도와달라 요청해봤다.

```
1. 첫 줄에서 코드의 줄 개수 C를 입력받는다.

2. C번 반복하면서 각 줄의 코드를 입력받는다.

3. 각 줄에서 "for"가 몇 번 등장하는지 센다.

4. "while"이 몇 번 등장하는지도 센다.

5. 두 개를 합쳐서 현재 줄의 반복문 개수를 구한다.

6. 지금까지의 최대값과 비교해서 더 크면 갱신한다.

7. 마지막에 최댓값을 출력한다.
```
라고 의사코드 [(pseudocode)](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C) 

를 적어주셨다.

내가 너무 디테일하게 코드부터 생각했었던 것 같다.

여기서 디테일하게 들어가는게 좋을것 같다고 생각이 든다.

# 3. 필요한 지식 정리 (Knowledge Requirement)

이제 여기서 Kotlin을 통해서 문제를 풀기위해

어떤 것들을 쓰면 좋을까 ?

```
1. 입력 받기 → readLine()

2. 문자열에서 특정 단어 세기 → string.count("for") 또는 정규식

3. 반복문 → for (i in 1..C)

4. 최댓값 저장 → maxOf 또는 변수로 갱신
```

아마도 이것들을 찾아면 좋을 것 같다.

문제 과정을 생각하고, 

코틀린에서 어떤 문법을 쓰면 좋을까 ? 를 

의사코드 **키워드**로 생각해서 연결지으면 문제를 푸는데 더 도움이 될 것 같다고 생각한다.

예로 들으면

```
3. 각 줄에서 "for"가 몇 번 등장하는지 센다.

4. "while"이 몇 번 등장하는지도 센다.
```

여기서는 **문자열을 센다.** 이라는 키워드가 있으니까

**문자열 특정 단어 개수 세기** 문법을 찾아가면 좋을 것 같다.

그렇게해서 이런 글이나 공식문서를 찾고,
[코틀린 String에서 특정 문자 개수 count (혹은 Int형 특정 숫자 개수)](https://toonraon.tistory.com/43)

이제 코드를 짜보면 될 것 같다.


# 4. 구현 (implement)
```kotlin
val C = readln().toInt() // 코드의 줄 개수 C 입력받기.
```
코드의 줄 개수를 입력받도록 

`readln()`과 `tonInt()` 를 통해
정수로 입력받았다. 왜냐하면 줄 개수는 0과 100사이기때문이고,

readln()은 항상 문자열(String) 형태로 입력받기 때문에
형변환을 정수로 시켜줬다.

```kotlin
    for(C:Int in 1..100) // 1<C<100 줄까지. 
        // 여기서 어케해야하지 ?
```
for문으로 1과 100사이 정수를 반복하게 하려고 했었는데,

이게 아닌것 같았음

**루프 변수** 에 대해서 정확하게 잘 몰랐던 것 같았음

추후 Loop에 대해 다시 공부를 해봐야겠다 생각했음
(예로들면 For문에서 Loop variable이 내부에서만 유효하도록 설계된 이유-스코프원칙)

나머지는 AI의 도움을 좀 받았기 때문에 어떻게 사고방식을 했는가를 적어달라고했다.

다음으로 넘어가서 `repeat()` 라는 코틀린에서의 함수 사용했다.

**왜 `for(C:Int in 1..100)`이 틀렸을까?**

이 접근법의 문제점은 "입력받은 줄 수만큼 반복"이 아니라 "1부터 100까지 모든 숫자에 대해 반복"하려고 했다는 것이다. 만약 사용자가 3줄의 코드를 입력한다고 했는데, 100번 반복하면서 입력을 받으려고 하면 입력이 부족해서 프로그램이 멈춰버릴 것이다.

올바른 사고방식은 "C번 반복해서 각각 한 줄씩 읽어라"여야 했다.

**`repeat(c)` 함수를 통한 해결**

```kotlin
repeat(c) {
    val line = readln()
    // 각 줄에서 for와 while 개수 세기
}
```

`repeat()` 함수는 정해진 횟수만큼 블록을 실행하는 간단한 방법이다. 루프 변수가 필요 없을 때 `for`문보다 의도가 더 명확하게 드러난다.

**문자열에서 패턴 찾기**

각 줄에서 "for"와 "while"을 세는 방법으로 정규표현식을 사용했다.

```kotlin
val countFor = Regex("for").findAll(line).count()
val countWhile = Regex("while").findAll(line).count()
```

`Regex("for").findAll(line)`은 해당 줄에서 "for"라는 패턴이 나타나는 모든 위치를 찾아내고, `.count()`로 그 개수를 센다. 이는 단순하지만 효과적인 방법이다.

**최댓값 추적 로직**

```kotlin
var maxCount = 0
// 각 줄마다
val total = countFor + countWhile
if (total > maxCount) {
    maxCount = total
}
```

매 줄을 처리할 때마다 현재 줄의 반복문 개수와 지금까지의 최댓값을 비교해서 더 큰 값으로 갱신하는 방식이다. 이렇게 하면 모든 줄을 다 본 후에 자연스럽게 최댓값을 얻을 수 있다.

이 과정을 통해 문제에서 요구하는 "같은 줄에 있는 반복문의 최대 개수"를 정확히 구할 수 있었다.


# 5. 검증 (Verification)

다음은 클로드를 통한 테스트케이스 검증이다
나중에 추후 혼자서도 어떻게해야할지 알아봐야할듯 싶다.

**테스트 케이스 1 검증:**
입력이 다음과 같을 때 우리 알고리즘이 올바르게 동작하는지 살펴보겠습니다.
```
3
for
forwhileforfor  
forwhileannsds
```

첫 번째 줄 `"for"`: `Regex("for").findAll("for").count()`는 1을 반환하고, `Regex("while").findAll("for").count()`는 0을 반환합니다. 따라서 total = 1 + 0 = 1이며, maxCount는 1로 갱신됩니다.

두 번째 줄 `"forwhileforfor"`: 이 문자열에서 "for"는 세 번 등장하고(위치 0, 8, 11), "while"은 한 번 등장합니다(위치 3). 따라서 total = 3 + 1 = 4가 되고, maxCount는 4로 갱신됩니다.

세 번째 줄 `"forwhileannsds"`: "for"가 한 번, "while"이 한 번 등장하므로 total = 1 + 1 = 2입니다. 이는 현재 maxCount인 4보다 작으므로 갱신되지 않습니다.

최종적으로 maxCount = 4가 출력되며, 이는 예상 출력과 일치합니다.

**테스트 케이스 2 검증:**
```
2
asdsdasds
dsdsdss
```

두 줄 모두에서 "for"와 "while"이 전혀 등장하지 않으므로, 각 줄의 total은 0 + 0 = 0입니다. maxCount는 초기값 0에서 변경되지 않고, 최종적으로 0이 출력됩니다.

**경계값 테스트:**
문제의 제약조건을 확인해보겠습니다. C의 최솟값은 1이고 최댓값은 100입니다. 각 줄의 최대 길이는 10,000자입니다. 우리 알고리즘의 시간복잡도는 O(C × L)이며, 여기서 L은 각 줄의 길이입니다. 최악의 경우에도 100 × 10,000 = 1,000,000번의 연산으로 충분히 1초 내에 처리 가능합니다.

**메모리 사용량 검증:**
각 줄을 하나씩 처리하고 즉시 처리하므로, 동시에 메모리에 저장되는 것은 현재 처리 중인 한 줄뿐입니다. 따라서 메모리 사용량은 O(L)이며, 주어진 1024MB 제한 내에서 충분합니다.

# 6. 문제점 (Problems & Limitations)

이 문제를 해결하는 과정에서 여러 가지 학습이 필요한 영역들이 드러났습니다.

**개념적 혼동의 문제:**
가장 큰 문제는 반복문의 목적을 명확히 이해하지 못한 것이었습니다. `for(C:Int in 1..100)`이라고 작성한 것은 "입력받은 줄 수만큼 반복"이라는 목표와 "1부터 100까지 반복"이라는 구현 사이의 괴리를 보여줍니다. 이는 문제 요구사항을 코드로 변환하는 과정에서 논리적 연결고리가 끊어진 것입니다.

**문법적 지식의 부족:**
루프 변수와 스코프에 대한 이해가 부족했던 것도 중요한 문제점입니다. 변수가 어디서 생성되고 어디까지 유효한지에 대한 개념이 명확하지 않으면, 복잡한 프로그램을 작성할 때 예상치 못한 오류가 발생할 수 있습니다.

**추상적 사고와 구체적 구현 사이의 간격:**
의사코드 작성은 잘 했지만, 이를 실제 코드로 옮기는 과정에서 막혔습니다. 이는 알고리즘적 사고와 프로그래밍 언어의 문법 사이의 연결이 아직 자연스럽지 않다는 것을 의미합니다.

**독립적 문제 해결 능력의 한계:**
중간에 AI의 도움을 받아야 했다는 것은 아직 스스로 문제를 끝까지 해결할 수 있는 자신감과 지식이 부족하다는 것을 보여줍니다. 이는 더 많은 연습과 기본기 강화가 필요함을 시사합니다.

**패턴 인식의 미흡:**
문자열에서 특정 패턴을 찾는 문제임을 인식했지만, 이를 정규표현식이나 문자열 메서드로 해결하는 방법을 바로 떠올리지 못했습니다. 이런 패턴-솔루션 매칭 능력은 더 많은 문제를 풀어보면서 기를 수 있을 것입니다.