
```cardlink
url: https://hyperskill.org/learn/step/10740
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


[간단한 속성을 가진 간단한 클래스를 선언하는 방법은 이미 알고 계실 겁니다. 이제 다른 종류의 클래스 멤버인](https://hyperskill.org/learn/step/10740 "Kotlin에서 클래스 멤버는 클래스에 속하는 구성 요소이며, 속성이나 함수가 될 수 있습니다. | 클래스 멤버는 자신이 속한 클래스 내에서 접근하고 사용할 수 있습니다. 함수의 경우, 멤버 함수는 클래스 내에 정의되어 클래스의 필드에 접근할 수 있는 함수입니다. 메서드라고도 하며, 같은 클래스에 속하는 객체 집합에 대한 공통 동작을 구현하는 데 사용됩니다. 클래스 멤버는 다른 클래스 내에 정의된 클래스인 중첩 클래스가 될 수도 있습니다. 중첩 클래스의 한 유형인 내부 클래스는 외부 클래스의 멤버에 접근할 수 있지만, 일반 중첩 클래스는 접근할 수 없습니다.") 생성자 에 대해 알아보겠습니다 .

## 기본 생성자

**생성자는** 클래스의 새 객체를 초기화하는 클래스 멤버입니다. 다시 말해, 생성자는 속성을 정의하여 새 객체의 상태를 설정합니다. 따라서 객체를 생성할 때 생성자를 호출합니다.

더 많은 예를 보려면 다음 클래스를 사용해 보겠습니다 `Size`.

```kotlin
class Size {
    var width: Int = 1
    var height: Int = 1
}
```

객체를 생성하는 방법을 잠시 생각해 봅시다. 클래스 이름과 그 뒤에 빈 괄호를 적습니다.

```kotlin
val size = Size()
```

이는 실제로 **생성자 호출** 이며, 인수 없이 함수를 호출하는 것과 같습니다. 모든 클래스에는 생성자가 있어야 하므로, 생성자가 명시적으로 정의되지 않으면 컴파일러는 자동으로 **인수 없는** **[기본 생성자를](https://hyperskill.org/learn/step/10740 "코틀린에서 기본 생성자는 클래스 이름 뒤, 클래스 헤더의 일부로 선언되는 특수한 유형의 생성자입니다. | 기본 생성자는 클래스 속성을 직접 또는 초기화 블록 내에서 초기화하는 데 사용되는 매개변수를 가질 수 있습니다. 기본 생성자는 코드를 포함할 수 없지만, 초기화 코드는 초기화 블록에 배치할 수 있습니다. 클래스에 기본 생성자로 처리할 수 없는 더 복잡한 초기화가 필요한 경우, 보조 생성자를 사용할 수 있습니다. 이러한 보조 생성자는 직접 또는 다른 보조 생성자를 통해 간접적으로 기본 생성자에게 위임해야 합니다.")** 생성합니다 . 이 생성자는 객체만 생성하고 내부에 로직은 없습니다.

## 기본 생성자

객체를 생성하기 전에 객체의 속성을 알고 있는 경우가 많습니다. 코드를 더 간결하게 만들려면 생성자에서 속성을 설정할 수 있습니다. 생성자가 필요한 인수를 받도록 설정하기만 하면 됩니다.

기본 **생성자는** 이러한 작업에 적합한 도구입니다. 기본 생성자는 코드를 포함하지 않고 클래스의 인스턴스와 속성을 초기화합니다. 기본 생성자를 정의하려면 클래스 이름 뒤의 괄호 안에 클래스 초기화 인수를 넣어야 합니다.

클래스의 기본 생성자는 `Size`다음과 같습니다.

```kotlin
class Size(width: Int, height: Int) {
    val width: Int = width
    val height: Int = height
    val area: Int = width * height
}
```

일반적으로 생성자를 정의하려면 매개변수 앞에 [키워드를](https://hyperskill.org/learn/step/10740 "코틀린에서 키워드는 언어 내에서 특별한 의미를 갖는 단어로, 프로그래머가 변경할 수 없습니다. | 코드의 구조와 동작을 정의하는 데 사용됩니다. 코틀린에서 키워드의 예로는 `fun` (함수 정의), `var` (변수 정의), `if` (조건문 정의) 등이 있습니다. 키워드는 코틀린에서 예약어이므로 식별자로 사용할 수 없습니다.") `constructor` 붙여야 합니다 . Kotlin의 기본 생성자는 키워드를 생략할 수 있습니다.

어떤 식으로든, 기본 생성자를 정의하는 또 다른 합법적인 방법은 다음과 같습니다.

```kotlin
class Size constructor(width: Int, height: Int) {
    val width: Int = width
    val height: Int = height
    val area: Int = width * height
}
```

## 재산 신고

기본 생성자 **안에** 간단한 [속성 선언을 넣을 수 있습니다.](https://hyperskill.org/learn/step/10740 "Kotlin에서 속성 선언은 클래스나 객체의 속성을 정의하는 방법으로, 속성은 자체 필드 대신 제공된 대리자에 의해 제어됩니다. | 이를 통해 유사한 속성 간에 기능을 공유할 수 있습니다. 위임된 속성을 선언하는 구문은 `var/val <속성 이름>: <속성 유형> by <대리자>`입니다. 대리자는 속성의 가져오기 및 설정 작업을 수행하는 `getValue` 함수(`var`의 경우 `setValue` 함수)를 제공해야 합니다. 이 메커니즘을 통해 클래스 필드가 아닌 맵과 같은 다른 객체로 속성을 지원할 수 있으므로 코드 가독성과 프로그래밍 경험이 향상됩니다.") [읽기 전용 속성을](https://hyperskill.org/learn/step/10740 "In Kotlin, a read-only property is a property that can only be read and not modified. | It is achieved by using the `val` keyword instead of `var` when declaring the property. The `val` keyword indicates that the property is immutable and can only be assigned a value once during initialization. This helps ensure the integrity of the data and prevent unintended modification. Additionally, read-only properties can be used to expose internal state in a safe and controlled manner, without allowing external code to modify it.") 선언하려면 인수 이름 앞 괄호 안에 키워드를 넣습니다 . 변경 가능한 속성의 경우 키워드를 사용합니다 .[](https://hyperskill.org/learn/step/10740 "코틀린에서 읽기 전용 속성은 읽을 수만 있고 수정할 수 없는 속성입니다. | 속성을 선언할 때 `var` 대신 `val` 키워드를 사용하면 됩니다. `val` 키워드는 해당 속성이 변경 불가능하며 초기화 중에 값을 한 번만 할당할 수 있음을 나타냅니다. 이는 데이터 무결성을 보장하고 의도치 않은 수정을 방지하는 데 도움이 됩니다. 또한, 읽기 전용 속성을 사용하면 외부 코드가 내부 상태를 수정하지 않고도 안전하고 제어된 방식으로 내부 상태를 노출할 수 있습니다.")`val``var`

[예를 들어, 클래스 본문](https://hyperskill.org/learn/step/10740 "In Kotlin, a class body refers to the section of a class declaration that contains the class members, such as properties, methods, and inner classes. | It is enclosed in curly braces `{}` and appears immediately following the class name and any visibility modifiers. The class body can be empty, as in the case of a marker interface, or it can contain a variety of member declarations.")`width` 에서 속성을 옮겨 보겠습니다 .[](https://hyperskill.org/learn/step/10740 "Kotlin에서 클래스 본문은 속성, 메서드, 내부 클래스 등 클래스 멤버를 포함하는 클래스 선언 부분을 의미합니다. | 중괄호 `{}`로 묶이며 클래스 이름과 가시성 한정자 바로 뒤에 위치합니다. 클래스 본문은 마커 인터페이스처럼 비어 있을 수도 있고, 다양한 멤버 선언을 포함할 수도 있습니다.")

```kotlin
class Size(val width: Int, height: Int) {
    val height: Int = height
    val area: Int = width * height
}
```

`height`이제 나머지 속성을 기본 생성자 내부에 넣어 보겠습니다 .

```kotlin
class Size(val width: Int, val height: Int) {
    val area: Int = width * height
}
```

## 기본 및 명명된 인수

기본 생성자의 기본값은 클래스 본문과 같은 방식으로 설정됩니다. 속성을 키워드 `val`또는 로 선언 `var`하고 대입 연산자 뒤에 기본값을 추가합니다.

```kotlin
class Size(var width: Int = 1, var height: Int = 1) {
    val area: Int = width * height
}
```

[기본 생성자에서 기본값을](https://hyperskill.org/learn/step/10740 "Kotlin에서 기본값은 함수 매개변수에 미리 할당된 값입니다. 즉, 해당 매개변수에 값을 명시적으로 지정하지 않고도 함수를 호출할 수 있으며, 기본값이 대신 사용됩니다. | 이 기능을 사용하면 모든 인수를 지정할 필요가 없는 경우 더욱 간결한 함수 호출이 가능합니다. 기본값은 함수 선언에서 타입 뒤에 `=` 연산자를 사용하여 지정되며, 함수를 호출할 때 명명된 인수를 제공하여 재정의할 수 있습니다.") 사용하여 클래스의 객체를 생성할 때 인수를 생략하여 기본값을 사용할 수 있습니다.

```kotlin
val size = Size() // width == 1, height == 1
```

클래스 인스턴스를 생성할 때 속성 이름 없이 값을 제공하거나 **명명된 인수를** 사용할 수 있습니다 .

```kotlin
val size1 = Size(3, 5) // width == 3, height == 5
val size2 = Size(width = 3, height = 5) // width == 3, height == 5
val size3 = Size(height = 5, width = 3) // width == 3, height == 5
```

객체를 생성할 때 기본값이 있는 일부 속성을 생략할 수도 있습니다. 단, 기본 생성자에서 인수 순서를 어길 경우 항상 명명된 인수를 사용해야 한다는 점을 명심하세요.

```kotlin
val sizeWide = Size(10) // width == 10, height == 1
val sizeHigh = Size(height = 10) // width == 1, height == 10
```

기본 생성자는 클래스를 간결하게 정의하는 편리한 방법입니다. 중복된 코드를 피하고 싶다면 기본 생성자와 기본 인수를 활용해 보세요.

## 단일 라인 클래스

기본 생성자에 있는 멤버 외에 다른 클래스 멤버가 남아 있지 않으면 빈 중괄호를 생략할 수 있습니다. `area`예제에서 해당 속성이 누락되었다고 가정해 보겠습니다.

```kotlin
class Size(val width: Int, val height: Int)
```

실생활에서 이러한 클래스를 자주 볼 수 있습니다. 예를 들어, **데이터 클래스** (주로 데이터를 저장하는 클래스)는 이런 방식으로 정의됩니다. 나중에 이에 대해 배우게 될 것입니다.

## 이니트

기본 생성자는 코드를 포함할 수 없습니다. 전달된 인수에 따라 클래스 속성의 값만 설정합니다. 경우에 따라 다른 속성의 값이나 다른 정보 출처를 기반으로 일부 속성을 설정해야 할 수도 있습니다. 이러한 경우에는 키워드 접두사가 붙은 **[초기화 블록을](https://hyperskill.org/learn/step/10740 "코틀린에서 초기화 블록은 `init` 키워드로 시작하는 코드 블록으로, 기본 생성자의 확장 기능을 합니다. | 기본 생성자는 전달된 인수에 따라서만 속성 값을 설정할 수 있으므로, 초기화 블록은 다른 속성 값이나 기타 정보를 기반으로 클래스 속성 값을 설정하는 데 사용됩니다. 클래스 본문에는 여러 개의 초기화 블록이 있을 수 있으며, 각각은 나타나는 순서대로 실행됩니다. 클래스 멤버와 구별하기 위해 밑줄로 시작하는 매개변수 이름을 사용하는 것은 유용한 코딩 규칙입니다.")**`init` 사용합니다 .

```kotlin
class Size(_width: Int, _height: Int) {
    var width: Int = 0
    var height: Int = 0

    init {
        width = if (_width >= 0) _width else {
            println("Error, the width should be a non-negative value")
            0
        }
        height = if (_height >= 0) _height else {
            println("Error, the height should be a non-negative value")
            0
        }
    }
}
```

키워드는 `init`기본 생성자의 확장 기능을 하는 코드 블록을 나타냅니다. 예를 들어, 아래 코드는 기본 생성자에서 객체 속성이 설정된 후 메시지를 출력합니다.

```kotlin
class Size(val width: Int, val height: Int) {
    init {
        println("Initializer block that prints the width ($width) and the height ($height)")
    }
}
```

클래스 본문에는 여러 개의 초기화 블록이 있을 수 있습니다. 이 경우, 속성 초기화 블록과 `init`초기화 블록은 표시된 순서대로 실행됩니다.

```kotlin
class Size(_width: Int, _height: Int) {
    // 1: the width property is initialized
    val width = _width

    // 2: 1st init block is executed
    init {
        println("First initializer block that prints the width $width")
    }

    // 3: the height property is initialized
    val height = _height

    // 4: 2nd init block is executed
    init {
        println("Second initializer block that prints the height $height")
    }

    // 5: the area property is initialized
    val area = width * height
}
```

위 예시에서 매개변수 이름은 클래스 멤버( , ) 와 구분하기 위해 밑줄( `_width`, )로 시작합니다 . 이는 다양한 프로그래밍 언어에서 널리 사용되는 유용한 코딩 규칙입니다.`_height``width``height`

## 결론

생성자에 대해 배운 내용을 다시 살펴보겠습니다.

- 모든 Kotlin 클래스에는 객체를 초기화하는 생성자가 있습니다.
    
- 클래스의 생성자가 명시적으로 정의되지 않으면 인수가 없는 암묵적 [기본 생성자가](https://hyperskill.org/learn/step/10740 "코틀린에서 기본 생성자는 명시적으로 정의된 생성자가 없는 클래스에 대해 암묵적으로 생성되는 생성자입니다. | 기본 생성자는 매개변수가 없으며, 속성을 초기화하지 않고 객체를 생성하는 데 사용됩니다. 클래스에 기본값이 있는 속성이 있는 경우, 해당 인수를 생략하거나 명명된 인수를 사용하여 객체를 생성할 때 이러한 값을 사용할 수 있습니다. 그러나 기본 생성자에서 인수 순서가 변경되는 경우에는 명명된 인수를 사용해야 합니다. 기본 생성자는 클래스를 정의하는 간결한 방법이며 중복 코드를 방지하는 데 도움이 될 수 있습니다.") 설정됩니다. 이 생성자는 속성을 초기화하지 않고 객체를 생성합니다.
    
- 생성자는 [클래스 이름](https://hyperskill.org/learn/step/10740 "Kotlin에서 클래스 이름은 클래스를 식별하는 고유 식별자로, 새 클래스를 선언하거나 해당 클래스의 객체를 생성하는 데 사용됩니다. 클래스 이름은 클래스 헤더에 지정되고, 그 뒤에 중괄호로 묶인 클래스 본문이 옵니다. 클래스 이름은 점(.)과 속성 또는 메서드 이름을 사용하여 속성이나 메서드와 같은 클래스 멤버에 액세스할 수 있습니다. 또한, 객체 생성 구문(빈 괄호)을 사용하여 클래스 인스턴스를 생성할 수도 있습니다. 또한, 클래스 이름은 데이터를 저장하고 클래스 전체 기능을 구현할 수 있는 동반 객체를 선언하는 데에도 사용할 수 있습니다.") 으로 호출할 수 있습니다 .
    
- 생성자를 선언하는 방법은 여러 가지가 있지만, 기본 생성자가 가장 간결합니다.
    
- 객체 생성 중에 일부 코드를 실행해야 하는 경우, 초기화 블록은 생성자와 함께 사용할 수 있습니다.
    

502