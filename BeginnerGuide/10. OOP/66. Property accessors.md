
```cardlink
url: https://hyperskill.org/learn/step/10511
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


이미 알고 계시겠지만, Kotlin의 각 클래스에는 **속성이** 0개 이상 있습니다 . 거의 모든 클래스에서 속성을 사용하게 될 것입니다. 이 주제에서는 속성을 변경하고 값을 가져오는 등 속성을 다루는 방법을 자세히 살펴보겠습니다.

## 속성 게터

`Client`하나의 속성을 가진 간단한 클래스가 있다고 가정해 보겠습니다 `name`.

```kotlin
class Client {
    val name = "Unknown"
}

val client = Client()
```

속성 이름을 검색하는 방법은 이미 알고 있습니다. 객체 이름 뒤에 점과 속성 이름을 입력하기만 하면 됩니다.

```kotlin
client.name
```

매우 간단해 보이지만, 실제로는 특정 속성의 값을 가져오려면 **getter**`get()` 라는 특수 함수를 호출합니다 . 실제 코드는 다음과 같습니다.

```kotlin
class Client {
    val name = "Unknown"
        get() {
            return field
        }
}

// or with omitted curly brackets and the body of the get() function

class Client {
    val name = "Unknown"
        get() = field
}
```

이 함수는 아무것도 받지 않고(값만 요청하고 그 이상은 요청하지 않습니다) 하나의 값을 반환합니다. 값을 가져오려고 하면 `get()`함수의 결과를 얻게 됩니다. 그렇다면 는 무엇일까요 `field`? 코틀린의 모든 속성은 자체적인 **[백킹 필드 를](https://hyperskill.org/learn/step/10511 "코틀린에서 백킹 필드는 속성 값을 저장하는 생성된 비공개 속성으로, 이를 통해 속성의 동작을 더욱 세부적으로 제어할 수 있습니다. | 코틀린에서 속성을 정의하면 해당 속성에 대한 백킹 필드가 자동으로 생성되며, 속성의 getter 또는 setter에서 `field` 키워드를 사용하여 액세스할 수 있습니다. 기본적으로 코틀린은 백킹 필드의 값을 반환하는 게터를 자동으로 생성합니다. 하지만 사용자 지정 게터 또는 세터를 제공하여 속성의 동작을 수정할 수 있습니다.")** [가지며, 이 필드는 특수 키워드 를](https://hyperskill.org/learn/step/10511 "Kotlin에서 키워드는 언어에서 특별한 의미를 갖는 단어로, 프로그래머가 변경할 수 없습니다. | 키워드는 코드의 구조와 동작을 정의하는 데 사용됩니다. Kotlin 키워드의 예로는 `fun`(함수 정의), `var`(변수 정의), `if`(조건문 정의) 등이 있습니다. 키워드는 Kotlin에서 예약어이므로 식별자로 사용할 수 없습니다. 반면 식별자는 코드의 변수, 함수, 클래스 또는 기타 엔티티에 지정된 이름입니다. 식별자는 코드를 더 읽기 쉽고 이해하기 쉽게 만드는 데 사용되며, 해당 범위 내에서 고유해야 하며 Kotlin의 명명 규칙을 따라야 합니다.") 사용하여 액세스할 수 있는 속성 값을 포함합니다 `field`.

이 경우, 게터는 변수의 값만 반환합니다 `name`. 이는 예상된 동작이므로 Kotlin이 이 함수를 자동으로 생성해 주므로 직접 작성할 필요가 없습니다. 게터의 로직을 변경하려면 직접 `get()`함수를 작성해야 합니다.

때로는 이러한 암묵적 지원 필드 체계에 맞지 않는 작업을 수행하고 싶을 때, 언제든지 **[지원 속성을](https://hyperskill.org/learn/step/10511 "Kotlin에서 지원 속성은 속성 접근자의 동작을 사용자 정의할 수 있는 속성의 추가 기능입니다. | 속성을 정의하면 컴파일러가 자동으로 생성한 지원 필드가 속성 값을 저장합니다. 하지만 지원 속성을 사용하여 지원 필드를 사용자 정의 getter 및 setter 메서드로 대체할 수 있습니다. 이렇게 하면 속성 값에 접근하고 수정하는 방식을 제어할 수 있어 캡슐화와 유연성이 한층 강화됩니다.")** 사용할 수 있습니다 . 예를 들어, 정보를 저장하는 변경 가능한 값을 사용하고 항상 읽기 전용 값을 반환할 수 있습니다.

```kotlin
class IntegerRepository {
    private val _list = mutableListOf<Int>()
    val list: List<Int> get() = _list // backing property
}

fun main() {
    val repository = IntegerRepository()
    repository.list.add(1) // Error: variable list is a read-only collection
    println(repository.list)
}
```

## 사용자 정의 게터

다음에 접근할 때마다 고객 이름을 출력해 보겠습니다 `name`. :

```kotlin
class Client {
    val name = "Unknown"
        get() {
            println("Somebody wants to know $field name")
            return field
        }
}

val client = Client()

val name = client.name // prints Somebody wants to know Unknown name
println(name)          // prints Unknown
```

[사용자 정의 게터](https://hyperskill.org/learn/step/10511 "Kotlin에서 사용자 지정 게터는 속성의 기본 게터 함수를 재정의하는 사용자 정의 함수입니다. | 기본적으로 Kotlin은 각 속성에 대해 속성의 지원 필드 값을 반환하는 게터 함수를 생성합니다. 하지만 속성 값이 계산되거나 반환되는 방식을 사용자 지정하려면 사용자 지정 게터 함수를 정의할 수 있습니다. 사용자 지정 게터는 속성 값을 반환하기 전에 추가 연산이나 계산을 수행하는 데 사용할 수 있습니다. 예를 들어, 날짜 또는 통화 값의 형식을 지정하거나 속성 값을 기반으로 복잡한 계산을 수행하는 데 사용할 수 있습니다. 또한, 속성에 대한 액세스를 제어하는 ​​데에도 사용할 수 있습니다. 예를 들어, 속성에 잘못된 방식으로 액세스했을 때 기본값이나 오류 메시지를 반환하는 등의 작업이 있습니다. 사용자 지정 게터의 또 다른 사용 사례는 속성의 지원 필드에 저장된 값과 다른 값을 반환하려는 경우입니다. 예를 들어, 사용자 지정 게터를 사용하여 배열이나 컬렉션의 하위 집합을 반환하거나 여러 속성의 값을 단일 값으로 결합할 수 있습니다.") 의 또 다른 용도는 다른 값을 반환하려는 경우입니다. 예를 들어, 전체 고객 정보를 변수에 저장하는 작업이 있을 수 있습니다. 한 사람의 정보를 변경하면 이 변수도 변경해야 합니다. 사용자 정의 게터를 사용하면 필요에 따라 정보를 생성할 수 있습니다. 아래 예시에서 클래스는 고객의 나이를 저장하는 속성과 해당 고객의 정보를 반환하는 속성을 `Client`가져옵니다 .`age``info`

```kotlin
class Client {
    var name: String = "Unknown"
    var age: Int = 18
    val info: String
        get() {
            return "name = $name, age = $age"
        }
}

val client = Client()
println(client.info) // name = Unknown, age = 18
client.name = "Lester"
client.age = 20
println(client.info) // name = Lester, age = 20
```

## 부동산 세터

이제 속성 값을 가져오는 과정을 사용자 지정할 수 있다는 것을 알았습니다. 속성 값을 변경하는 과정도 수정할 수 있습니다! 간단한 예를 살펴보겠습니다.

```kotlin
class Client {
    var name = "Unknown" // default value
}

val client = Client()
client.name = "Ann"      // name property now stores "Ann"
```

속성 값을 설정하려면 **setter**`set()` 라는 특수 함수를 호출해야 합니다 . 함수의 형태는 다음과 같습니다.

```kotlin
class Client {
    var name = "Unknown"
        set(value) {
            field = value
        }
}
```

이 함수는 하나의 인수를 받습니다(관례에 따라 이름이 지정 `value`되지만 다른 이름을 사용할 수도 있습니다). 그리고 아무것도 반환하지 않습니다. 아시다시피 는 `field`속성의 현재 값을 포함하며, 다른 값을 다시 할당하여 값을 변경할 수 있습니다.

이 경우, 세터 함수는 변수의 값을 `name`수신된 값으로 변경합니다. 이는 예상된 동작이며, Kotlin이 자동으로 이 함수를 생성해 주므로 세터 함수를 직접 작성할 필요가 없습니다.

## 커스텀 세터

이 `set()`함수는 강력한 도구이며, 세터의 로직을 사용자 정의할 수 있습니다. 예를 들어, 속성을 변경할 때마다 고객의 이름을 출력해 보겠습니다 `name`.

```kotlin
class Client {
    var name = "Unknown"
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
}

val client = Client()
client.name = "Ann"   // The name is changing. Old value is Unknown. New value is Ann.
```

알다시피, 세터는 속성을 변경하려고 할 때만 호출되고, [초기화할](https://hyperskill.org/learn/step/10511 "코틀린에서 초기화는 변수가 선언될 때 초기값을 할당하는 것을 의미합니다. `=` 기호 다음에 값을 지정하여 초기화할 수 있습니다. `val` 키워드를 사용하는 경우 초기화가 필수적입니다. 기본 클래스에 생성자 매개변수가 있는 경우 파생 클래스에서 이를 처리해야 합니다. 코틀린은 기본 클래스가 제대로 초기화되지 않으면 프로그램 컴파일을 허용하지 않습니다. 초기화는 간단한 객체의 경우 가벼운 작업이지만, 더 복잡한 클래스의 인스턴스를 생성하는 것은 비용이 많이 들 수 있습니다.") 때는 호출되지 않습니다 .

[사용자 지정 세터를](https://hyperskill.org/learn/step/10511 "Kotlin에서 사용자 지정 세터는 속성 세터의 동작을 사용자 지정할 수 있는 추가 기능입니다. | 기본적으로 세터는 속성 값을 수신된 값으로 변경합니다. 하지만 필요에 따라 이 동작을 수정할 수 있습니다. 예를 들어, 속성 값이 변경될 때마다 메시지를 출력하거나 특정 조건에 따라 다른 값을 할당할 수 있습니다. 사용자 지정 세터의 일반적인 사용 사례는 고객의 나이와 같은 속성을 음수 값으로 설정할 수 없도록 하는 것입니다.") 사용하는 또 다른 방법은 다른 값을 할당하는 것입니다. `age`클라이언트의 나이를 저장하는 속성을 추가해 보겠습니다. 물론 나이는 음수가 될 수 없습니다. 나이를 고려하고 싶다면 사용자 지정 세터를 추가할 수 있습니다.

```kotlin
class Client {
    var name = "Unknown"
    var age = 18
        set(value) {                      
            field = if (value < 0) {
                println("Age cannot be negative. Set to $defaultAge")
                defaultAge
            } else
                value
        }
    val defaultAge = 18
}

val client = Client()
client.age = -1      // Age cannot be negative. Set to 18.
println(client.age)  // 18
```

## 추가 기능

속성에 대해 setter와 getter를 모두 구현할 수 있습니다.

```kotlin
class Client {
    var name = "Unknown"
        get() {
            println("Somebody wants to know $field name")
            return field
        }
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
}
```

생성자에서 속성에 getter 및/또는 setter를 추가하려면 속성을 "이동"하기만 하면 됩니다. 이 경우 생성자의 속성이 아닌 다른 변수를 사용해야 한다는 점을 기억하세요.

```kotlin
class Client(name: String, age: Int) {
    var fullName: String = name
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
    var age: Int = age   // this is a new property, not a property from the constructor
        set(value) {
            println("The age is changing. Old value is $field. New value is $value.")
            field = value
        }
}
```

속성을 초기화할 때 setter는 호출되지 않는다는 점에 유의하세요. 이는 속성을 초기화하는 생성자에도 적용됩니다. 자세히 살펴보겠습니다.

```kotlin
class Client(name: String) {
    var name: String = name
        set(value) {
            println("The name is changing. Old value is $field. New value is $value.")
            field = value
        }
}

val client = Client("Annie")  // without output
client.name = "Ann"           // The name is changing. Old value is Annie. New value is Ann.
```

변수 에는 세터(setter)를 사용할 수 없습니다 `val`. `set()`함수가 변수를 재할당하는데, 이는 .에서는 불가능합니다 `val`. 물론, `val`속성의 내부 상태를 다른 방식으로 변경할 수 있습니다. 예를 들어, 자체 세터(setter)를 사용하는 방법이 있습니다.

```kotlin
class Passport(number: String) {
    var number = number
    set(value) {
        println("Passport number has changed.")
        field = value
    }
}

class Client {
    val passport = Passport("1234567")
}

val client = Client()
println(client.passport.number)       // 1234567
/*
client.passport = Passport("2345678") // This will not work.
*/
client.passport.number = "2345678"    // This will change the passport number
                                      // prints Passport number has changed
println(client.passport.number)       // 2345678
```

## 결론

[Kotlin 속성은 클래스 필드를](https://hyperskill.org/learn/step/10511 "Kotlin에서 클래스 필드는 클래스 내부에 선언되어 값을 저장하는 변수 또는 속성입니다. 필드는 숫자, 문자열 또는 기타 객체와 같은 다양한 유형일 수 있으며, 선언된 클래스 내에서 접근하고 수정할 수 있습니다. 필드의 가시성은 `private`, `protected` 또는 `public`과 같은 접근 제한자를 사용하여 제어할 수 있습니다. 클래스 외부에서 비공개 필드에 접근하려면 getter 및 setter 메서드를 사용할 수 있습니다. 필드는 생성자를 통해 초기화할 수도 있으며, 가시성 제한자를 지정할 수도 있습니다.") 다루는 매우 실용적인 방법입니다 . 이제 기본 게터 및 세터 메서드와 그 사용자 정의에 대해 알게 되었습니다. 로깅 및 입력 처리와 같은 다양한 상황에서 도움이 되는 매우 강력한 도구입니다.