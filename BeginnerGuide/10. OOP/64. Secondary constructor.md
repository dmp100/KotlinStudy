
```cardlink
url: https://hyperskill.org/learn/step/10746
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


[기본 생성자를](https://hyperskill.org/learn/step/10746 "코틀린에서 기본 생성자는 클래스 이름 뒤, 클래스 헤더의 일부로 선언되는 특수한 유형의 생성자입니다. | 기본 생성자는 클래스 속성을 직접 또는 초기화 블록 내에서 초기화하는 데 사용되는 매개변수를 가질 수 있습니다. 기본 생성자는 코드를 포함할 수 없지만, 초기화 코드는 초기화 블록에 배치할 수 있습니다. 클래스에 기본 생성자로 처리할 수 없는 더 복잡한 초기화가 필요한 경우, 보조 생성자를 사용할 수 있습니다. 이러한 보조 생성자는 직접 또는 다른 보조 생성자를 통해 간접적으로 기본 생성자에게 위임해야 합니다.") 사용하는 방법은 이미 알고 있습니다 . 하지만 기본 생성자에는 한계가 있습니다. 예를 들어, 같은 클래스에 대해 여러 개의 생성자를 만들어야 할 때 기본 생성자만으로는 이를 수행할 수 없습니다. 이럴 때 보조 생성자 또는 사용자 지정 생성자가 유용합니다.

## 사용자 정의 생성자

기본 생성자와 함께 또는 기본 생성자 없이 클래스에 대한 **[사용자 정의 생성자를](https://hyperskill.org/learn/step/10746 "코틀린에서 사용자 정의 생성자는 클래스의 속성을 초기화하는 데 사용되는 특수 메서드입니다. | 클래스 본문 내에 선언되며 자체 매개변수 목록을 갖습니다. 기본 생성자와 달리, 사용자 정의 생성자를 사용하면 동일한 클래스에 대해 각 생성자가 클래스 속성을 초기화하는 고유한 로직을 갖는 여러 생성자를 만들 수 있습니다. 이는 서로 다른 초기값을 가진 클래스의 여러 인스턴스를 생성해야 할 때 유용합니다.")** 선언할 수 있습니다 .

[보조 생성자를](https://hyperskill.org/learn/step/10746 "코틀린에서 보조 생성자는 기본 생성자와 함께 클래스에 정의할 수 있는 추가 생성자입니다. | 기본 생성자로는 충분하지 않거나 추가 초기화 단계를 수행해야 할 때 사용됩니다. 보조 생성자는 클래스 본문 내에서 `constructor` 키워드 뒤에 생성자의 매개변수를 포함하는 괄호를 사용하여 정의됩니다. 보조 생성자는 기본 생성자보다 유연성이 뛰어나지만, 기본 생성자에게 명시적으로 위임해야 합니다. 보조 생성자의 본문이 실행되기 전에 기본 클래스의 생성자가 완료되어야 합니다.") 선언하려면 클래스 본문 안에 키워드를 작성 `constructor`하고 키워드 뒤에 생성자의 매개변수를 괄호로 묶습니다. 그런 다음 생성자 로직을 중괄호 안에 입력합니다.

```kotlin
class Size {
    var width: Int = 0
    var height: Int = 0

    constructor(_width: Int, _height: Int) {
        width = _width
        height = _height
    }
}
```

이제 기본 생성자를 사용하는 것처럼 한 줄로 객체를 생성할 수 있습니다.

```kotlin
val size1 = Size(3, 4)
val size2 = Size(5, 1)
```

주의하세요: 암묵적 생성자를 사용하거나 직접 생성자를 선언해야 하지만, 두 가지를 동시에 사용할 수는 없습니다.

```kotlin
class Size {
    var width: Int = 0
    var height: Int = 0

    constructor(_width: Int, _height: Int) {
        width = _width
        height = _height
    }
}

val size = Size() // Error! No values passed for parameters _width and _height
```

[당신이 할 수 있는 것은 기본 생성자](https://hyperskill.org/learn/step/10746 "코틀린에서 기본 생성자는 명시적으로 정의된 생성자가 없는 클래스에 대해 암묵적으로 생성되는 생성자입니다. | 기본 생성자는 매개변수가 없으며, 속성을 초기화하지 않고 객체를 생성하는 데 사용됩니다. 클래스에 기본값이 있는 속성이 있는 경우, 해당 인수를 생략하거나 명명된 인수를 사용하여 객체를 생성할 때 이러한 값을 사용할 수 있습니다. 그러나 기본 생성자에서 인수 순서가 변경되는 경우에는 명명된 인수를 사용해야 합니다. 기본 생성자는 클래스를 정의하는 간결한 방법이며 중복 코드를 방지하는 데 도움이 될 수 있습니다.") 의 복제본을 명시적으로 만드는 것입니다(빈 중괄호는 제거될 수 있습니다):

```kotlin
// preferable solution
class Size() { 
    var width: Int = 0
    var height: Int = 0
}

// or this way

class Size {
    var width: Int = 0
    var height: Int = 0

    constructor() {
    }
}
```

## 여러 생성자

클래스에 여러 생성자를 만드는 것은 하나만 만드는 것만큼 간단하지만, 한 가지 명심해야 할 제약 조건이 있습니다. 모든 보조 생성자는 고유한 시그니처를 가져야 합니다. 주 생성자나 다른 생성자에 동일한 시그니처를 사용할 수 없습니다.

생성자 시그니처는 매개변수의 개수, 유형, 그리고 순서로 구성됩니다. 유효한 생성자를 만들려면 고유한 매개변수 목록을 가져야 합니다. 예를 들어, 클래스의 다음 생성자들을 살펴보겠습니다 `Size`.

```kotlin
class Size {
    var width: Int = 0
    var height: Int = 0

    constructor(_height: Int) {
        height = _height
    }

    constructor(_width: Int, _height: Int) {
        width = _width
        height = _height
    }

    constructor(_width: Int, _height: Double) {
        width = _width
        height = _height.toInt()
    }

    constructor(_height: Double, _width: Int) {
        width = _width
        height = _height.toInt()
    }
}
```

아래 코드는 `Size`서로 다른 생성자를 사용하여 동일한 속성 값을 갖는 네 개의 객체를 생성합니다.

```kotlin
val size1 = Size(7) // uses 1st constructor
val size2 = Size(0,7) // uses 2nd constructor
val size3 = Size(0, 7.0) // uses 3rd constructor
val size4 = Size(7.0, 0) // uses 4th constructor
```

시그니처는 매개변수의 이름이 아니라 타입에 따라 정의된다는 점을 기억하세요. 예를 들어, 컴파일러는 사람이 보기에 두 생성자가 달라도 두 생성자를 구분할 수 없습니다.

```kotlin
constructor(width: Int, height: Int) {}
constructor(x: Int, y: Int) {}
```

따라서 같은 클래스에서 이러한 생성자를 구현하면 오류가 발생합니다.

## `this`예어

클래스 코드 내부에서 `this`현재 객체를 나타내는 특수 키워드를 사용하여 객체 멤버에 액세스할 수도 있습니다.

예를 들어, 생성자 매개변수의 이름을 클래스 속성과 동일하게 지정할 수 있습니다. 클래스를 다음과 같이 변경해 보겠습니다 `Size`.

```kotlin
class Size {
    var width: Int = 0
    var height: Int = 0

    constructor(width: Int, height: Int) {
        this.width = width
        this.height = height
    }
}
```

[위의 코드에서는 키워드가](https://hyperskill.org/learn/step/10746 "코틀린에서 키워드는 언어 내에서 특별한 의미를 갖는 단어로, 프로그래머가 변경할 수 없습니다. | 코드의 구조와 동작을 정의하는 데 사용됩니다. 코틀린에서 키워드의 예로는 `fun` (함수 정의), `var` (변수 정의), `if` (조건문 정의) 등이 있습니다. 키워드는 코틀린에서 예약어이므로 식별자로 사용할 수 없습니다.") 없으면 오류가 발생합니다 . 이름이 [변경 불가능한](https://hyperskill.org/learn/step/10746 "코틀린에서 불변 변수는 초기화되면 변경할 수 없는 객체 또는 변수 유형입니다. | 이는 데이터 무결성을 보장하고 의도치 않은 수정을 방지하는 데 도움이 됩니다. 예를 들어, 책의 페이지 목록은 불변 컬렉션일 수 있으며, 시간이 지나도 내용이 변경될 수 없습니다. 반면, 가변 컬렉션은 저장된 항목을 추가, 제거 또는 업데이트하는 등의 변경을 허용합니다. `val` 키워드를 사용하여 선언된 불변 변수는 외부 코드에서 수정할 수 없으므로 안전하고 제어된 방식으로 내부 상태를 노출하는 데 특히 유용합니다.")`this` 생성자 매개변수 로 해석되고 클래스 멤버로 해석되지 않기 때문입니다.[](https://hyperskill.org/learn/step/10746 "코틀린에서 불변 변수는 초기화되면 변경할 수 없는 객체 또는 변수 유형입니다. | 이는 데이터 무결성을 보장하고 의도치 않은 수정을 방지하는 데 도움이 됩니다. 예를 들어, 책의 페이지 목록은 불변 컬렉션일 수 있으며, 시간이 지나도 내용이 변경될 수 없습니다. 반면, 가변 컬렉션은 저장된 항목을 추가, 제거 또는 업데이트하는 등의 변경을 허용합니다. `val` 키워드를 사용하여 선언된 불변 변수는 외부 코드에서 수정할 수 없으므로 안전하고 제어된 방식으로 내부 상태를 노출하는 데 특히 유용합니다.")

## 기본값 생략

[기억하시겠지만, 생성자에서 속성 값이 할당된 경우 기본값을](https://hyperskill.org/learn/step/10746 "Kotlin에서 기본값은 함수 매개변수에 미리 할당된 값입니다. 즉, 해당 매개변수에 값을 명시적으로 지정하지 않고도 함수를 호출할 수 있으며, 기본값이 대신 사용됩니다. | 이 기능을 사용하면 모든 인수를 지정할 필요가 없는 경우 더욱 간결한 함수 호출이 가능합니다. 기본값은 함수 선언에서 타입 뒤에 `=` 연산자를 사용하여 지정되며, 함수를 호출할 때 명명된 인수를 제공하여 재정의할 수 있습니다.") 제공할 필요가 없습니다 .

```kotlin
class Size (var width: Int, var height: Int) {
    // whatever you want
}
```

이는 보조 생성자에도 적용됩니다. 클래스에서 `var`를 로 변경하여 속성을 재할당할 수 없도록 해보겠습니다. 설명을 위해 생성자 매개변수를 기반으로 계산되는 또 다른 속성을 추가해 보겠습니다.`val``Size``area`

```kotlin
class Size {
    val width: Int
    val height: Int
    val area: Int

    constructor(width: Int, height: Int) {
        this.width = width
        this.height = height
        this.area = width * height
    }
}
```

재할당처럼 보이지만 값을 초기화하는 것일 뿐이므로 문제가 없습니다.

2차 생성자에서는 키워드를 `val`사용할 수 없습니다 .`var`

```kotlin
class Size {
    constructor(val width: Int, val height: Int) { // error, val is not allowed
    }
}
```

## 생성자 위임

클래스에 기본 생성자가 있으면, 각 보조 생성자는 기본 생성자를 직접 또는 다른 보조 생성자를 통해 간접적으로 호출해야 합니다. 이를 **위임** 이라고 합니다 .

같은 클래스의 다른 생성자에게 위임하려면 `this`생성자 인수 뒤, 생성자 본문 앞에 키워드를 붙여야 합니다.

```kotlin
class Size(val width: Int, val height: Int) {
    var area: Int = width * height

    constructor(width: Int, height: Int, outerSize: Size) : this(width, height) {
        outerSize.area -= this.area
        println("Updated outer object's area is equal to ${outerSize.area}")
    }
}
```

기본 생성자로의 위임은 보조 생성자의 첫 번째 명령문이 되므로, 보조 생성자 코드가 실행되기 전에 속성이 초기화됩니다. 초기화 블록이 있는 경우, 해당 블록도 보조 생성자보다 먼저 실행됩니다. 클래스에 기본 생성자가 없는 경우, 위임은 암묵적으로 발생합니다.

## 생성자 실행

예제를 살펴보고 클래스 코드가 어떤 순서로 실행되는지 살펴보겠습니다.

```kotlin
class Size(val width: Int, val height: Int) {
    var area: Int = width * height

    init {
        println("Object with area equal to $area is created")
    }

    constructor(width: Int, height: Int, outerSize: Size) : this(width, height) {
        outerSize.area -= this.area
        println("Updated outer object's area is equal to ${outerSize.area}")
    }
}

fun main() {
    val outerObject = Size(5, 8)
    val innerObject = Size(2, 3, outerObject)
}
```

생성 시 `outerObject`, 기본 생성자가 직접 호출되고, 속성이 초기화되고 `init`블록이 실행됩니다. 의 경우 `innerObject`, 보조 생성자가 먼저 기본 생성자를 호출하고, 속성 초기화와 초기화 블록이 실행된 후, 마지막으로 보조 생성자 코드가 실행됩니다.

결과는 다음과 같습니다.

```no-highlight
Object with area equal to 40 is created
Object with area equal to 6 is created
Updated outer object's area is equal to 34
```

## 결론

연습으로 넘어가기 전에 주제의 핵심 요점을 검토해 보겠습니다.

- 클래스는 보조 생성자도 선언할 수 있습니다. 보조 생성자는 키워드를 접두사로 사용해야 합니다 `constructor`.
    
- 같은 클래스 내의 각 생성자는 고유한 시그니처를 가져야 합니다.
    
- 클래스 코드 내부의 객체 멤버는 `this`키워드로 접근할 수 있습니다.
    
- 생성자에서 속성 값을 할당하는 경우 기본값을 생략할 수 있습니다.
    
- [초기화 블록](https://hyperskill.org/learn/step/10746 "코틀린에서 초기화 블록은 `init` 키워드로 시작하는 코드 블록으로, 기본 생성자의 확장 기능을 합니다. | 기본 생성자는 전달된 인수에 따라서만 속성 값을 설정할 수 있으므로, 초기화 블록은 다른 속성 값이나 기타 정보를 기반으로 클래스 속성 값을 설정하는 데 사용됩니다. 클래스 본문에는 여러 개의 초기화 블록이 있을 수 있으며, 각각은 나타나는 순서대로 실행됩니다. 클래스 멤버와 구별하기 위해 밑줄로 시작하는 매개변수 이름을 사용하는 것은 유용한 코딩 규칙입니다.") 의 코드는 실질적으로 기본 생성자의 일부가 됩니다.
    
- 2차 생성자 코드는 1차 생성자, 초기화 블록, 속성 초기화 이후에 실행됩니다.
