
```cardlink
url: https://hyperskill.org/learn/step/6200
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


프로그래머가 객체 지향 프로그램을 구현할 때, 이미 정의된 클래스를 사용하여 프로그램을 만드는 경우가 많습니다. 예를 들어, `Scanner`클래스의 객체를 사용하면 콘솔 입력에서 다음 단어를 가져올 수 있으며, 이 단어 자체가 `String`클래스의 객체입니다. 그럼에도 불구하고, 프로그래머는 여전히 프로그램별 클래스를 선언해야 하는 경우가 많습니다. 이 주제에서는 간단한 클래스를 직접 만들고 사용하는 몇 가지 방법을 살펴보겠습니다.

## 새로운 클래스 선언

`class`새 클래스를 선언하려면 키워드와 **클래스 이름을** 뒤에 적어야 합니다 . 먼저, 다음 [과 같은 이름의 클래스를](https://hyperskill.org/learn/step/6200 "Kotlin에서 클래스 이름은 클래스를 식별하는 고유 식별자로, 새 클래스를 선언하거나 해당 클래스의 객체를 생성하는 데 사용됩니다. 클래스 이름은 클래스 헤더에 지정되고, 그 뒤에 중괄호로 묶인 클래스 본문이 옵니다. 클래스 이름은 점(.)과 속성 또는 메서드 이름을 사용하여 속성이나 메서드와 같은 클래스 멤버에 액세스할 수 있습니다. 또한, 객체 생성 구문(빈 괄호)을 사용하여 클래스 인스턴스를 생성할 수도 있습니다. 또한, 클래스 이름은 데이터를 저장하고 클래스 전체 기능을 구현할 수 있는 동반 객체를 선언하는 데에도 사용할 수 있습니다.") 선언해 보겠습니다 `Emptiness`.

```kotlin
class Emptiness {
    // empty body
}
```

코틀린에서는 클래스의 본문이 비어 있을 때 중괄호 **를** **[생략](https://hyperskill.org/learn/step/6200 "코틀린에서 중괄호 `{}`는 0개 이상의 명령문을 포함할 수 있는 코드 블록을 나타내는 데 사용됩니다. | 또한 문자열 템플릿에서 복잡한 표현식이나 객체 속성을 평가하는 데에도 중괄호를 사용합니다. 표현식이 더 복잡한 경우, 달러 기호 `$` 다음에 중괄호를 사용하여 표현식을 감싸고 사용할 수 있습니다. 문자열 템플릿에서는 실수를 방지하고 코드 가독성을 높이기 위해 항상 표현식에 중괄호를 사용하는 것이 좋습니다.")** **할** 수 있습니다 . 따라서 동일한 클래스를 다음과 같이 정의할 수 있습니다.

```kotlin
class Emptiness
```

클래스는 파일에서 선언할 수 있습니다 `.kt`. 일반적으로 파일 최상위에 선언하는 것이 좋지만, 함수 내부를 포함한 다른 곳에서도 선언할 수 있습니다.

## 객체 생성

클래스를 선언하는 목적은 무엇일까요? 간단히 말해서, 정의된 각 **클래스는** **새로운 타입을** 생성합니다 . 따라서 클래스의 객체를 생성하고 변수와 값으로 저장할 수 있습니다. 때로는 표준 타입만으로는 충분하지 않을 때 이 기능이 유용합니다. 나중에 몇 가지 예를 통해 더 명확하게 설명하겠습니다.

클래스 [인스턴스를](https://hyperskill.org/learn/step/6200 "Kotlin에서 인스턴스는 런타임 중에 생성되는 객체 또는 클래스의 인스턴스를 나타냅니다. | Kotlin에서 알려진 모든 유형의 하위 유형이므로 유형 검사 측면에서 모든 유형의 값을 나타낼 수 있습니다. 이는 특히 함수에 반환 유형이 필요하지만 값을 반환할 수 없는 상황(예: 값이 0인 경우 백분율을 계산하는 경우)에서 유용합니다. 이러한 경우 `Instance`를 반환하는 함수를 사용할 수 있습니다. 인스턴스의 개념은 스레딩과도 관련이 있는데, 스레딩에서는 단 하나의 스레드만 특정 인스턴스의 동기화된 메서드에서 코드를 실행할 수 있습니다. 즉, 여러 스레드가 동시에 여러 객체의 메서드를 실행할 수 있으며, 이는 인스턴스당 하나의 스레드로 요약할 수 있는 개념입니다.") 생성하려면 **클래스 이름** 과 **빈 괄호** 만 작성하면 됩니다 . 즉, [구문은](https://hyperskill.org/learn/step/6200 "코틀린에서 구문은 프로그램을 언어로 작성하는 방식을 결정하는 일련의 규칙과 관례를 의미합니다. | 구문에는 명령문, 표현식, 키워드의 구조뿐만 아니라 들여쓰기, 공백, 주석의 사용도 포함됩니다. 예를 들어 표현식은 리터럴 값, 변수, 함수 호출 또는 연산자를 사용하여 이러한 요소의 조합과 같은 단일 값으로 평가되는 구문 유형입니다. 코틀린의 구문을 이해하는 것은 명확하고 유지 관리가 용이하며 오류 없는 코드를 작성하는 데 필수적입니다.") 함수를 호출하는 것과 비슷합니다. 예를 들어 `Emptiness`클래스에 대해 다음과 같이 작성해 보겠습니다.

```kotlin
val empty: Emptiness = Emptiness()
```

`Emptiness`방금 클래스의 새 객체를 변수에 할당했습니다 `empty`. 이 변수는 `Emptiness`타입을 가지므로 다른 타입의 객체를 재할당할 수 없습니다. 일반적으로 Kotlin에서는 명시적인 타입 지시어를 생략할 수 있습니다.

```kotlin
val empty = Emptiness()
```

## 학급 회원

클래스 [본문 에는](https://hyperskill.org/learn/step/6200 "Kotlin에서 클래스 본문은 속성, 메서드, 내부 클래스 등 클래스 멤버를 포함하는 클래스 선언 부분을 의미합니다. | 중괄호 `{}`로 묶이며 클래스 이름과 가시성 한정자 바로 뒤에 위치합니다. 클래스 본문은 마커 인터페이스처럼 비어 있을 수도 있고, 다양한 멤버 선언을 포함할 수도 있습니다.") **[클래스 멤버가](https://hyperskill.org/learn/step/6200 "Kotlin에서 클래스 멤버는 클래스에 속하는 구성 요소이며, 속성이나 함수가 될 수 있습니다. | 클래스 멤버는 자신이 속한 클래스 내에서 접근하고 사용할 수 있습니다. 함수의 경우, 멤버 함수는 클래스 내에 정의되어 클래스의 필드에 접근할 수 있는 함수입니다. 메서드라고도 하며, 같은 클래스에 속하는 객체 집합에 대한 공통 동작을 구현하는 데 사용됩니다. 클래스 멤버는 다른 클래스 내에 정의된 클래스인 중첩 클래스가 될 수도 있습니다. 중첩 클래스의 한 유형인 내부 클래스는 외부 클래스의 멤버에 접근할 수 있지만, 일반 중첩 클래스는 접근할 수 없습니다.")** 포함될 수 있습니다 . 지금은 Kotlin에서 **필드를** 대체하는 **속성** 에 대해서만 살펴보겠습니다 . **속성은 데이터도 저장할** 수 있습니다 . 속성과 다른 클래스 멤버의 다른 장점에 대해서는 다음 주제에서 살펴보겠습니다.

모든 클래스 멤버는 선택 사항입니다. 예를 들어, `Emptiness`클래스에는 속성이 없습니다.

## 쓰기 속성

속성은 변수 및 값과 매우 유사합니다. 런타임 중에 속성에 값을 할당하려면 a 로 선언하고 `var`, 그렇지 않으면 a 를 `val`사용합니다.

또한 모든 속성에는 엄격한 유형이 있습니다. 숫자나 문자열과 같은 표준 유형이거나 사용자 지정 유형일 수 있습니다. 따라서 속성 유형은 사용자 정의 클래스일 수도 있고, 속성이 선언된 클래스일 수도 있습니다.

데이터만 저장하는 속성은 어떻게든 **초기값을** 받아야 합니다 . 예를 들어, 클래스 본문에서 속성을 설정할 수 있습니다.

클래스에는 필요한 만큼의 속성이 있을 수 있습니다.

이제 병원 정보 시스템에서 환자를 표현하는 클래스를 선언해 보겠습니다.

```kotlin
class Patient {
    var name: String = "Unknown"
    var age: Int = 0
    var height: Double = 0.0
}
```

여기서 우리는 `Patient`클래스에 재할당할 수 있는 세 가지 속성, 이름, 나이, 키가 있는 것을 볼 수 있습니다.

클래스의 각 객체는 **동일한 필드 집합을** 갖지만 , 필드의 **값은** 객체마다 **다를 수 있습니다 .**

## 속성에 액세스하기

이제 객체 속성에 접근하는 방법을 알아보겠습니다. 먼저 객체를 생성해야 합니다.

```kotlin
var patient = Patient()
```

아직 객체 속성을 변경하지 않았으므로 이제 초기값이 있습니다. 해당 속성의 값을 가져오려면 객체 이름 뒤에 **점과 속성 이름을 입력하세요.**

```kotlin
println(patient.name) // prints "Unknown"
println(patient.age)  // prints "0"
```

## 속성 변경

아래 예를 살펴보세요. 이 프로그램은 두 명의 환자를 생성하고 속성을 설정한 후 출력합니다.

```kotlin
class Patient {
    var name: String = "Unknown"
    var age: Int = 0
    var height: Double = 0.0
}

fun main() {
    val john = Patient()
    john.name = "John"
    john.age = 30
    john.height = 180.0

    val alice = Patient()
    alice.name = "Alice"
    alice.age = 22
    alice.height = 165.0

    println("${john.name}: ${john.age} yrs, ${john.height} cm")
    println("${alice.name}: ${alice.age} yrs, ${alice.height} cm")
}
```

출력은 다음과 같습니다.

```no-highlight
John: 30 yrs, 180.0 cm
Alice: 22 yrs, 165.0 cm
```

앨리스의 속성을 할당할 때 존의 속성은 변경되지 않는다는 점에 유의하세요.

또한, `val`before 는 a 를 에 `alice`재할당할 수 없다는 것을 의미합니다 . 하지만 의 속성은 클래스 내부에 로 표시되어 있으므로 재할당할 수 있습니다 .`Patient``alice``alice``var``Patient`