
```cardlink
url: https://hyperskill.org/learn/step/6621
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


개발자는 모든 것을 처음부터 작성하기보다는 이미 작성된 코드를 사용하는 경우가 많습니다. 이렇게 하면 시간을 절약할 수 있습니다. 하지만 다른 개발자가 작성한 코드일 경우, 사용된 코드를 수정할 수 없다는 단점이 있습니다. 작업을 최적화하는 방법을 살펴보겠습니다!

## 기존 클래스의 문제

수정할 수 없는 클래스를 사용하려면 해당 클래스의 객체를 인수로 받는 함수를 작성하면 됩니다.

```kotlin
fun repeated(string: String): String = string + string

repeated("ha")  // returns "haha"
```

여기서 문제가 보이시나요? 코틀린에서는 표준 연산을 [멤버 함수](https://hyperskill.org/learn/step/6621 "코틀린에서 멤버 함수는 클래스 내에서 선언되어 같은 클래스에 속하는 객체 집합에 대해 공통된 동작을 구현하는 함수입니다. | 클래스의 특정 객체에 대해 동작하고 해당 객체의 필드에 접근할 수 있기 때문에 멤버 함수라고 합니다. 'this' 키워드는 클래스의 현재 인스턴스를 나타내며 멤버 함수를 호출하는 데 사용됩니다.") 로 사용할 수 있습니다 . 예를 들어 `"ha"`문자열의 첫 번째 기호를 가져오려면 를 작성할 수 있습니다 `"ha".first()`. 모든 연산에 단일 [구문을](https://hyperskill.org/learn/step/6621 "코틀린에서 구문은 프로그램을 언어로 작성하는 방식을 결정하는 일련의 규칙과 관례를 의미합니다. | 구문에는 명령문, 표현식, 키워드의 구조뿐만 아니라 들여쓰기, 공백, 주석의 사용도 포함됩니다. 예를 들어 표현식은 리터럴 값, 변수, 함수 호출 또는 연산자를 사용하여 이러한 요소의 조합과 같은 단일 값으로 평가되는 구문 유형입니다. 코틀린의 구문을 이해하는 것은 명확하고 유지 관리가 용이하며 오류 없는 코드를 작성하는 데 필수적입니다.") 사용하는 것이 더 편리합니다 . 그렇다면 편집할 수 없는 클래스에 멤버 함수를 어떻게 추가할 수 있을까요 `String`?

## 확장 함수 정의 및 호출

코틀린에는 이에 딱 맞는 **구문적 편의 기능이 있습니다. 바로** [확장 함수입니다](https://hyperskill.org/learn/step/6621 "코틀린에서 확장 함수는 기존 클래스에서 마치 해당 클래스의 멤버인 것처럼 호출할 수 있지만, 실제로는 클래스 외부에 정의된 함수입니다. | 개발자는 이를 통해 원래 클래스 코드를 수정하지 않고 기존 클래스에 새로운 기능을 추가할 수 있습니다. 확장 함수는 수신자 객체(확장하려는 클래스)를 첫 번째 인수로 받으며, 이 인수는 암시적으로 전달됩니다. 일반 함수처럼 인수를 받고 값을 반환할 수 있습니다. 클래스에 동일한 이름과 시그니처를 가진 멤버 함수와 확장 함수가 모두 있는 경우, 멤버 함수가 우선합니다.")`repeated` . 이 함수를 확장 함수로 다시 작성해 보겠습니다 .

```kotlin
fun String.repeated(): String = this + this
```

`"haha"`이제 우리가 쓸 수 있는 것을 얻으려면

```kotlin
"ha".repeated()
```

보시다시피, 확장 함수를 정의하는 구문은 일반 함수를 정의하는 것과 같습니다. 확장하려는 클래스 **이름을** 쓰고 함수 이름 앞에 **점을** 추가하기 **만 하면 됩니다. 확장할 클래스** **를** **[수신자 타입](https://hyperskill.org/learn/step/6621 "In Kotlin, a receiver type is a special parameter of a lambda function that gives it the ability to access the members (properties and methods) of the corresponding receiver object directly, without any qualifier. | It is specified before the dot in the notation, for example, `Integer. () -> Unit` represents a function type that can be called on an integer receiver object. A lambda with a receiver is similar to an extension function, and it allows you to define behavior for a specific object or class.")** 이라고 합니다 .**[](https://hyperskill.org/learn/step/6621 "코틀린에서 수신자 타입은 람다 함수의 특수 매개변수로, 한정자 없이 해당 수신자 객체의 멤버(속성 및 메서드)에 직접 접근할 수 있도록 합니다. | 표기법에서 점 앞에 지정됩니다. 예를 들어, `Integer.() -> Unit`은 정수 수신자 객체에서 호출할 수 있는 함수 타입을 나타냅니다. 수신자가 있는 람다는 확장 함수와 유사하며, 특정 객체나 클래스의 동작을 정의할 수 있도록 합니다.")**

확장 함수에서도 멤버 함수에서와 마찬가지로 객체의 필드에 쉽게 접근할 수 있습니다. 이 객체를 **[수신자 객체](https://hyperskill.org/learn/step/6621 "Kotlin에서 수신자 객체는 함수를 통해 기능을 확장하는 객체 인스턴스입니다. | 암시적 또는 명시적일 수 있으며, 확장 함수가 호출되는 객체입니다. 수신자와 함께 람다를 사용할 때, 람다의 매개변수 중 하나에 수신자의 특수 상태를 부여하여 한정자 없이 해당 멤버를 직접 참조할 수 있습니다. 이렇게 하면 람다 본문에서 메서드가 어떻게 확인되는지 나타낼 수 있고, 추가 한정자 없이 본문에서 람다 수신자의 가시적인 메서드와 속성에 접근할 수 있습니다.")** 라고 합니다 .

```kotlin
class Client(val name: String, val age: Int)

fun Client.getInfo() = "$name $age" // Client is the receiver type


val client = Client("John", 32)
print(client.getInfo()) // client is the receiver object
```

개발자가 일부 정보를 숨기면 (나중에 방법을 알려드리겠습니다) 코드에서 해당 정보를 가져올 수 없게 되므로 확장 함수도 접근할 수 없습니다. 따라서 멤버 함수가 아닌 단순 함수처럼 작동합니다.

다른 함수와 마찬가지로 확장 함수는 인수를 받고 수신자 유형과 동일한 유형을 포함한 모든 유형의 **값을 반환할 수 있습니다** **.**

따라서 문제는 해결되었습니다. Kotlin 개발자는 원하는 클래스에 원하는 함수를 추가할 수 있습니다.

[Kotlin 표준 라이브러리](https://hyperskill.org/learn/step/6621 "Kotlin에서 표준 라이브러리는 Kotlin 프로그래밍 언어의 기본적인 부분으로, 언어에 포함되어 있으며 언어 작업에 필수적인 기능을 제공합니다. | 다양한 프로그래밍 작업을 효율적으로 처리할 수 있는 강력한 도구 세트를 제공하며 Kotlin의 언어 기능과 원활하게 작동하도록 설계되었습니다. 표준 라이브러리에는 미리 빌드된 기능을 제공하는 함수, 클래스 및 메서드가 포함되어 있으며, 코드에서 호출하거나 사용할 수 있으므로 이러한 기능을 처음부터 작성하는 데 드는 시간과 노력을 절약할 수 있습니다. Kotlin 표준 라이브러리에서 제공하는 기능의 예로는 각도의 사인 및 코사인과 같은 복잡한 수학 계산을 처리하는 것이 있습니다. 표준 라이브러리는 언어에 포함되어 필수 기능을 제공하는 라이브러리와 특수 또는 고급 기능을 제공하는 타사 라이브러리로 분류할 수 있습니다.") 에서도 확장 함수가 사용된다는 점을 언급해야 합니다 . 예를 들어 클래스 정의를 살펴보면 `String`필요한 멤버 함수만 보입니다. 와 같은 다른 함수들은 `.first()`클래스 `.toUpperCase()`코드를 단순화하기 위해 필요한 확장 함수입니다.

## 확장 함수 대 멤버 함수

다음과 같은 클래스가 있다고 가정해 보겠습니다.

```kotlin
class A {
    fun member() = println("hi from member")
}

fun A.extension() = println("hi from extension")
```

두 함수 모두 같은 방식으로 호출할 수 있습니다: `A().member()`. `A().extension()`. 따라서 호출하는 코드만 봐서는 멤버 함수인지 확장 함수인지 확실히 알 수 없습니다. 구현 부분을 확인해야 합니다.

개발자가 이미 존재하는 함수를 클래스에 추가하려고 하면 어떻게 될까요? 여러 가지 경우가 있을 수 있기 때문에 답은 다소 복잡합니다.

다른 를 정의하려고 하면 `fun A.extension()`코드가 컴파일되지 않습니다. 항상 그렇듯이 두 함수를 동일한 시그니처로 정의할 수는 없습니다.

를 추가하면 `fun A.member() = println("bye from not member")`코드는 컴파일되지만, 호출하면 `A().member()`를 반환합니다 `"hi from member"`.

따라서 **멤버 함수는 항상 승리합니다** . 이는 누군가가 의도적이든 의도치 않든 객체의 동작을 변경하려고 할 때 유용합니다.

확장 함수에 이미 존재하는 이름을 지정하려면 함수의 시그니처를 변경해야 합니다. 예를 들어 인수를 변경해야 합니다. 이렇게 해도 기존 코드는 손상되지 않습니다.

## 관용구

확장 함수는 기존 클래스에 기능을 추가하는 관용적인 방법입니다. 사용하기 간편하고 새 함수가 클래스와 밀접한 관련이 있음을 보여줍니다. 커뮤니티의 승인을 받아 사용하세요! 이 관용구는 [kotlinlang.org](https://kotlinlang.org/docs/idioms.html#extension-functions) 에 문서화되어 있습니다 .

```kotlin
fun String.spaceToCamelCase() { ... }

"Convert this to camelcase".spaceToCamelCase()
```

## 결론

확장 함수는 기존 클래스를 사용하는 데 도움이 되는 유용한 도구입니다. 때로는 이 클래스를 변경할 수 없을 수도 있고, 어떤 경우에는 기능을 추가해야 하는데 클래스에 저장하면 공간을 많이 차지하기 때문에 저장하고 싶지 않을 수도 있습니다. 확장 함수는 이 모든 경우에 좋은 해결책입니다. 작업 잘 되시길 바랍니다!

