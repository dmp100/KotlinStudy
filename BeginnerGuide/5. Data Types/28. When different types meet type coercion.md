
```cardlink
url: https://hyperskill.org/learn/step/9506
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


[타입 변환](https://hyperskill.org/learn/step/9506 "Kotlin에서 타입 변환은 값을 한 데이터 유형에서 다른 데이터 유형으로 전환하는 과정으로, Kotlin이 정적 타입 언어이기 때문에 매우 중요합니다. | 타입 변환은 명시적이며, Kotlin의 정적 타입 특성으로 인해 컴파일 타임에 타입을 식별하고 엄격하게 적용하기 때문에 신중하게 처리해야 합니다. Kotlin에서는 정밀도 손실이나 예상치 못한 결과를 방지하기 위해 암시적 변환을 허용하지 않습니다. Kotlin에서 변수를 한 데이터 유형에서 다른 데이터 유형으로 전환해야 할 때는 toInt(), toDouble() 등의 메서드를 사용하여 명시적 타입 변환을 수행해야 합니다. 타입 강제 변환은 정보 손실 없이 값을 한 데이터 유형에서 더 넓은 데이터 유형으로 자동 변환하는 것입니다.") 방법은 이미 알고 계실 겁니다 . 하지만 더 고급적인 측면도 있습니다. 예를 들어, `Int`타입이 있는 변수를 변수에 할당할 수 없다는 것을 알고 계실 겁니다. 하지만 변수 와 변수 `Long`의 합을 계산한다면 어떻게 될까요 ? 이 경우, 타입은 문맥에서 유추됩니다.`Int``Long`

## 유형 강제 변환

이러한 경우 컴파일러는 자동으로 모든 구성 요소( **[형 변환](https://hyperskill.org/learn/step/9506 "코틀린에서 타입 강제 변환은 값을 한 타입에서 타입 계층 구조에서 더 넓은 다른 타입으로 정보 손실 없이 자동 변환하는 것입니다. | 이는 결과의 타입이 이전 타입보다 더 넓은 경우 발생하며, 코틀린에서는 드물게 발생하며 숫자 및 문자열 타입만 지원합니다. 컴파일러는 모든 구성 요소와 결과 타입을 표현식에서 가장 넓은 타입으로 자동 설정하여 변환 중 정보 손실이 발생하지 않도록 합니다. 타입 강제 변환은 값을 한 타입에서 다른 타입으로 명시적으로 변환하는 타입 변환과는 다릅니다.")** 이라고 함 )와 결과 유형을 표현식에서 가장 넓은 유형으로 설정합니다. 아래 그림은 이러한 형 변환의 방향을 보여줍니다.

![Byte와 Short에서 Double로 왼쪽에서 오른쪽으로 변수 유형의 전송 방향](https://ucarecdn.com/f6fd5591-06db-4ba1-a67f-9c6bfcffd526/)

결과의 유형이 이전 유형보다 넓기 때문에 정보 손실이 없습니다.

Kotlin에서는 타입 강제 변환이 거의 발생하지 않습니다. 숫자와 문자열에만 적용됩니다.

## 예시

이론은 꽤 명확해 보입니다. 유형 강제의 몇 가지 예를 살펴보겠습니다.

- 에서 `Int`까지 `Long`:
    

```kotlin
val num: Int = 100
val longNum: Long = 1000
val result = num + longNum // 1100, Long
```

는 1100에 불과 하지만 , 와 변수 `result`의 합이므로 유형은 자동으로 로 변환됩니다 . 결과를 로 선언하려고 하면 오류가 발생합니다. Long 유형의 값을 Int 변수에 할당할 수 없기 때문입니다. 유형 의 변수에는 값이나 정수만 할당할 수 있습니다 .`Long``Int``Long``Int``Int``Int`

- 에서 `Long`까지 `Double`:
    

```kotlin
val bigNum: Long = 100000
val doubleNum: Double = 0.0
val bigFraction = bigNum - doubleNum // 100000.0, Double
```

## Short 및 Byte 유형

[서로 다른 유형의 변수를 포함하는 표현식](https://hyperskill.org/learn/step/9506 "코틀린에서 표현식은 값으로 평가되는 코드 조각입니다. | 표현식은 간단한 리터럴 값, 변수, 함수 호출 또는 연산자나 다른 언어 구문을 사용하여 이러한 요소들을 더 복잡하게 조합한 것일 수 있습니다. 표현식은 함수에서 값을 계산하고 반환하고, 변수에 값을 할당하고, 조건문에서 계산이나 연산을 수행하는 데 사용됩니다. 예를 들어, 2 \* 2는 표현식이며 단일 값을 생성합니다.") 의 결과가 가장 넓은 유형으로 자동 변환되는 방식을 확인할 수 있습니다 . 그러나 이러한 점에서 {} `Byte`및 {} `Short`유형은 특이합니다. 이러한 유형으로 계산을 수행해야 하는 경우, 계산 결과는 다음과 같습니다 `Int`.

- `Byte`그리고`Byte`
    

```kotlin
val one: Byte = 1
val two: Byte = 2
val three = one + two // 3, Int
```

- `Short`그리고`Short`
    

```kotlin
val fourteen: Short = 14
val ten: Short = 10
val four = fourteen - ten // 4, Int
```

- `Short`그리고`Byte`
    

```kotlin
val hundred: Short = 100
val five: Byte = 5
val zero = hundred % five // 0, Int
```

`Byte`그렇다면 두 변수를 더해서 결과를 얻고 싶다면 어떻게 해야 할까요 `Byte`? 이 경우에는 직접 타입 변환을 수행해야 합니다.

```kotlin
val one: Byte = 1
val five: Byte = 5
val six = (one + five).toByte() // 6, Byte
```

`Byte`범위 내에서 데이터를 저장할 수 있다는 것을 기억하세요`-128.. 127.`

아래 예제를 통해 오버플로 유형이 어떻게 작동하는지 살펴보세요.

```kotlin
fun main() {
    val a: Byte = 120
    println((a + a).toByte()) // prints -16 because 120+120 > 127
}
```

## 결론

요약하자면, 서로 다른 [숫자형을](https://hyperskill.org/learn/step/9506 "Kotlin에서 숫자형은 숫자를 표현할 수 있는 데이터형의 한 종류입니다. | 여기에는 `Int`, `Long`과 같은 정수형과 `Float`, `Double`과 같은 소수 부분을 포함한 숫자를 표현할 수 있는 부동 소수점형이 포함됩니다. 정수형은 크기가 다르고 값의 범위도 다릅니다. 예를 들어 `Int`는 -2^31에서 2^31-1까지의 값을 표현할 수 있는 반면, `Long`은 -2^63에서 2^63-1까지의 값을 표현할 수 있습니다. 마찬가지로 부동 소수점형은 정밀도 수준이 다르며, `Double`이 `Float`보다 더 정확합니다.") 갖는 표현식이 있는 경우 다음 규칙을 사용하여 결과의 ​​유형을 알아보세요.

1. [두 피연산자](https://hyperskill.org/learn/step/9506 "코틀린에서 피연산자는 연산자가 적용되는 값 또는 변수입니다. | 예를 들어, 표현식 1 + 3에서 1과 3은 피연산자이고 +는 연산자입니다. 피연산자는 리터럴, 변수 또는 더 복잡한 표현식일 수 있습니다. 코틀린에는 덧셈(+), 뺄셈(-), 곱셈(*), 나눗셈(/), 나머지(%)의 다섯 가지 산술 연산자가 있습니다. 이러한 연산자는 이진 연산자로, 두 개의 피연산자를 사용합니다. 피연산자의 평가는 연산자 우선순위라는 일련의 규칙에 따라 수행되며, 연산자는 이 규칙에 따라 적용됩니다.") 중 하나가 유형이면 `Double`결과는 입니다 `Double`.
    
2. 그렇지 않은 경우, 두 피연산자 중 하나가 유형이면 `Float`결과는 입니다 `Float`.
    
3. 그렇지 않은 경우, 두 피연산자 중 하나가 유형이면 `Long`결과는 입니다 `Long`.
    
4. 그렇지 않으면 결과는 .입니다 `Int`.
    

변수에 값을 넣을 때 타입 강제 변환은 발생하지 않습니다. 예를 들어, 10은 타입 이고 타입을 요구하기 `val longValue: Long = 10.toInt()`때문에 는 올바르지 않습니다 .`Int``longValue``Long`

컴파일러는 표현식의 타입을 자동으로 추론합니다. 간단한 경우에는 타입 변환을 생략하는 데 도움이 되지만, 혼동과 오류를 방지하려면 컴파일러의 작동 방식을 이해해야 합니다.