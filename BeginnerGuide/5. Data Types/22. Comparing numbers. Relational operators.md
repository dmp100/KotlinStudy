
```cardlink
url: https://hyperskill.org/learn/step/4525
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


## 관계 연산자 목록

Kotlin은 숫자를 다루는 6개의 [관계 연산자를 제공합니다.](https://hyperskill.org/learn/step/4525 "코틀린에서 관계 연산자는 두 값을 비교하고 그 관계를 결정하는 데 사용됩니다. | 코틀린에는 같음(==), 같지 않음(!=), 초과(>), 크거나 같음(>=), 미만(<), 작거나 같음(<=)의 여섯 가지 관계 연산자가 있습니다. 관계 연산자의 결과는 피연산자 유형에 관계없이 부울 값입니다. 관계 연산자를 사용하면 두 정수를 비교하는 등의 작업을 수행할 수 있습니다. 관계 연산자는 산술 연산자보다 우선순위가 낮으므로 함께 사용할 때는 주의해야 합니다.")

- `==`— ~와 같다`X`
    
- `!=`— 같지 않음`X`
    
- `>`—보다 크다`X`
    
- `>=`— 이상`X`
    
- `<`— 미만`X`
    
- `<=`— 이하`X`
    

관계 연산자는 피연산자 유형에 관계없이 부울 값( `true`또는 )을 반환합니다.`false`

## 정수 비교

관계 연산자를 사용하면 두 정수를 비교하는 등의 작업을 할 수 있습니다. 다음은 몇 가지 예입니다.

```kotlin
val one = 1
val two = 2
val three = 3
val four = 4

val oneIsOne = one == one // true

val res1 = two <= three // true
val res2 = two != four  // true
val res3 = two > four   // false
val res4 = one == three // false
```

[관계 연산자는 산술 연산자](https://hyperskill.org/learn/step/4525 "Kotlin에서 산술 연산자는 덧셈, 뺄셈, 곱셈, 나눗셈, 모듈로 나눗셈과 같은 수학 연산을 수행하는 데 사용되는 기호입니다. | 이러한 연산자는 피연산자라고도 하는 두 개의 값 또는 변수를 입력으로 사용하여 단일 출력을 생성합니다. 예를 들어, 1 + 3 표현식에서 1과 3은 피연산자이고 +는 연산자입니다. 곱셈은 덧셈이나 뺄셈보다 우선순위가 높으므로 먼저 계산됩니다. 괄호를 사용하여 실행 순서를 지정하고 표기법을 단순화할 수 있습니다. 예를 들어, 아래 프로그램은 산술 연산을 사용하여 숫자를 역순으로 출력하여 숫자를 추출합니다. Kotlin에서 나누기 연산자는 슬래시(/)로 표시합니다. 두 숫자를 나누고 몫을 반환합니다.") 와 함께 사용할 수 있습니다 . 이러한 표현식에서는 관계 연산자가 산술 연산자보다 우선순위가 낮습니다.

아래 예를 살펴보겠습니다. 먼저, Kotlin은 두 개의 합을 계산한 후, `>`연산자를 사용하여 두 값을 비교합니다.

```java
val number = 1000
val result = number + 10 > number + 9 // 1010 > 1009 is true
```

결과는 `true`.

`Int`그리고 `Long`! 의 동등성을 확인할 수 없다는 점에 유의하세요. 그리고 , . , , 를 `Int`자유롭게 비교할 수 있지만, 그리고 를 사용할 수는 없습니다 . 같은 타입에 대해서만 [동등성을](https://hyperskill.org/learn/step/4525 "In Kotlin, equality refers to the concept of comparing two variables or objects to determine if they are the same. | There are two types of equality: structural equality and referential equality. Structural equality checks if the inner state of the variables or objects are equal, and you can use the `==` operator to check for structural equality. On the other hand, referential equality checks if the variables or objects point to the same memory location, and you can also use the `==` operator to check for referential equality. It is important to note that the `const` keyword in Kotlin means that a variable cannot be reassigned, but it does not guarantee immutability.") 확인할 수 있으므로 , 다음과 같이 변환해야 합니다 .`Long``>``<``>=``<=``==``!=`[](https://hyperskill.org/learn/step/4525 "코틀린에서 동등성(equality)은 두 변수나 객체를 비교하여 동일한지 확인하는 개념을 의미합니다. | 동등성에는 구조적 동등성과 참조 동등성, 두 가지 유형이 있습니다. 구조적 동등성은 변수나 객체의 내부 상태가 동일한지 검사하며, `==` 연산자를 사용하여 구조적 동등성을 검사할 수 있습니다. 반면, 참조 동등성은 변수나 객체가 같은 메모리 위치를 가리키는지 검사하며, `==` 연산자를 사용하여 참조 동등성을 검사할 수도 있습니다. 코틀린에서 `const` 키워드는 변수가 재할당될 수 없음을 의미하지만, 불변성을 보장하지는 않습니다.")`Int``Long`

```kotlin
val one: Long = 1
val zero: Int = 0

println(one >= zero)          // OK, prints true  
// println(one == zero)          Error
println(one == zero.toLong()) // OK, prints false
```

## 관계형 작업 결합

[Kotlin은 다음과 같은 표현식을](https://hyperskill.org/learn/step/4525 "코틀린에서 표현식은 값으로 평가되는 코드 조각입니다. | 표현식은 간단한 리터럴 값, 변수, 함수 호출 또는 연산자나 다른 언어 구문을 사용하여 이러한 요소들을 더 복잡하게 조합한 것일 수 있습니다. 표현식은 함수에서 값을 계산하고 반환하고, 변수에 값을 할당하고, 조건문에서 계산이나 연산을 수행하는 데 사용됩니다. 예를 들어, 2 \* 2는 표현식이며 단일 값을 생성합니다.") 처리할 수 없습니다 .

```java
a <= b <= c
```

대신 논리 연산자(예: `||`and) 를 사용하여 두 개의 부울 표현식을 결합해야 합니다 .`&&`

예를 들어, 다음 표현식의 유효성을 확인해야 한다고 가정해 보겠습니다.

```java
100 < number < 200
```

그렇게 하려면 다음과 같이 작성해야 합니다.

```java
number > 100 && number < 200
```

또한, 표현식의 다른 부분을 괄호 안에 넣을 수도 있습니다.

```java
(number > 100) && (number < 200)
```

하지만 관계 연산자의 우선순위가 더 높으므로 괄호는 반드시 필요하지 않습니다.

[논리 연산자를](https://hyperskill.org/learn/step/4525 "코틀린에서 논리 연산자는 하나 이상의 부울 값을 결합하여 결과 부울 값을 제공하는 연산자 유형입니다. | 코틀린에는 not, exclusive or (xor), and, and or의 네 가지 주요 논리 연산자가 있습니다. 논리 연산자를 사용하면 일련의 관계 연산을 하나의 표현식으로 결합할 수 있습니다. 논리 연산자는 관계 연산자보다 우선순위가 높습니다. 예를 들어, a > b && c < d 표현식은 a가 b보다 크고 c가 d보다 작음을 의미합니다. 괄호를 사용하여 실행 순서를 변경할 수 있습니다.") 사용하면 일련의 관계 연산을 하나의 표현식으로 결합할 수 있습니다. 이는 프로그래밍에서 널리 사용되는 기술입니다.

좀 더 복잡한 예로, 정수를 읽고 숫자가 `[100; 200]` 100과 200을 포함한 다음 범위에 속하는지 확인하는 프로그램을 작성해 보겠습니다.

```kotlin
fun main() {
    val left = 100
    val right = 200
    val number = readln().toInt()

    val inRange = number >= left && number <= right // joining two expressions using AND

    println(inRange)
}
```

다음과 같은 것이 있을 수 있습니다.

- 50개의 결과`false`
    
- 99개의 결과`false`
    
- 100개의 결과`true`
    
- 200은 `true`, 등으로 결과가 나옵니다.
    

## 결론

이 주제에서는 매우 유용한 관계 연산자 몇 가지 `==`, `!=`, `>`, , `>=`, `<`, 에 대해 살펴보았습니다 `<=`. 논리 연산자를 사용하여 복잡한 문장을 구성할 수 있습니다. 하지만 이러한 연산자는 항상 [부울 값을](https://hyperskill.org/learn/step/4525 "코틀린에서 부울 값은 true 또는 false 두 가지 값만 취할 수 있는 특수 데이터 유형입니다. | 부울 값은 상점의 개점 여부와 같이 두 가지 상반된 상태를 나타내는 데 자주 사용됩니다. 코틀린에서는 대소문자를 구분하지 않고 부울 값을 읽고 입력값이 true이면 값을 반환할 수 있습니다. 또한, 'not', 'and', 'or', 'xor'와 같은 논리 연산자를 사용하여 true 또는 false의 부울 값을 반환합니다.") 반환한다는 점을 기억하세요 . 앞으로 Kotlin 프로그램에서 이러한 연산자를 구현하는 방법을 살펴보겠습니다.