
```cardlink
url: https://hyperskill.org/learn/step/4488
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```

## Int 및 long 정수 유형

프로그래머는 프로그램에서 정수를 자주 사용합니다. 기억하시겠지만, 코틀린에는 여러 [정수 타입이](https://hyperskill.org/learn/step/4488 "Kotlin에서 정수 타입은 소수점 없이 정수를 나타내는 데이터 타입입니다. 32비트에서는 `int`, 64비트에서는 `long` 타입으로 표현할 수 있습니다. 정수 변수를 사용하면 덧셈, 뺄셈, 곱셈, 나눗셈, 모듈러스와 같은 산술 연산을 수행할 수 있습니다. `int` 타입의 변수를 선언하려면 다음 방법 중 하나를 사용할 수 있습니다. `int` 범위 내의 값을 할당하거나, 변수 이름 뒤에 타입을 지정하거나, 값에 `u`(unsigned) 또는 `L`(long) 접미사를 붙여 값을 지정합니다.") 있습니다 . 가장 널리 사용되는 것은 `Int`(32비트)와 (64비트)입니다. 이러한 타입의 변수를 사용하여 모든 유형의 산술 연산( , , , , ) `Long`을 수행할 수 있습니다 . 몇 가지 예를 살펴보겠습니다.`+``-``*``/``%`

```kotlin
val two = 2  // Int
val ten = 10 // Int

val twelve = two + ten // 12
val eight = ten - two  // 8
val twenty = two * ten // 20
val five = ten / two   // 5
val zero = ten % two   // 0, no remainder 
```

이 연산들이 어떤 역할을 하는지 아시죠? `Long`정수형은 이러한 모든 연산을 지원합니다. 해당 유형의 변수를 선언하려면 `Long`다음 방법 중 하나를 선택할 수 있습니다.

```kotlin
val longNumber1 = 1_000_000_000_000_000
val longNumber2: Long = 1_000_000
val longNumber3 = 1000L

val result = longNumber1 + longNumber2 - longNumber3
println(result) // 1000000000999000
```

값 `longNumber1`은 해당 `Long`유형의 가능한 값보다 크기 때문에 해당 `Int`유형입니다. `longNumber2`또한, `Long`해당 유형을 지정했기 때문에 값이 있습니다. 값에 접미사 ( ) 를 붙였기 때문에 값 `longNumber3`이 있습니다 . 세 정수 의 합이므로 입니다 .`Long``L``Long``result``Long``Long`

**팁:**`Long` 정수는 절대적으로 필요한 경우에만 사용하세요 (예: 큰 값을 처리할 때).

`_`위 예시에서 밑줄을 보셨나요 ? 코틀린에서는 [밑줄을](https://hyperskill.org/learn/step/4488 "코틀린에서 밑줄은 단어 경계, 특히 영숫자 문자 또는 밑줄과 영숫자가 아닌 문자 사이의 경계를 나타내는 약어입니다. | 특정 문자와 일치하지 않고, 영숫자 또는 밑줄과 공백 문자, 문자열의 시작 또는 끝과 같은 영숫자가 아닌 문자 사이의 경계와 일치합니다. 특정 문자로 시작하거나 끝나는 모든 단어, 또는 영숫자가 아닌 문자가 앞뒤에 오는 문자를 일치시키는 데 사용할 수 있습니다.") 사용하여 숫자의 가독성을 높일 수 있습니다. 밑줄을 사용하여 숫자를 그룹화할 수 있습니다. 밑줄은 숫자의 시작이나 끝에는 사용할 수 없지만, 정수(숫자 사이) 내에서는 연속적으로 사용할 수 있습니다.

## 표준 입력에서 숫자 읽기

문제를 해결하려면 일반적으로 입력에서 데이터를 읽고, 처리하고, 결과를 출력해야 합니다. 예를 들어, 이 프로그램은 표준 입력에서 두 숫자를 읽고, 덧셈을 수행한 후 그 합을 출력합니다.

```kotlin
fun main() {
    val a = readln().toInt()
    val b = readln().toInt()

    val sum = a + b

    println(sum)
}
```

이 `readln()`부분은 데이터를 읽는 역할을 합니다. 이 부분은 양수, 음수, 0을 `Int`모두 지원하므로 모든 숫자에 적용됩니다.

입력 숫자가 클 수 있다는 것을 알고 있다면 `Longs`대신 다음 을 읽을 수 있습니다 `Ints`.

```kotlin
val a = readln().toLong()
val b = readln().toLong()
```

그 후에는 아무것도 바꿀 필요가 없습니다.

## 부호 없는 정수

Kotlin의 모든 정수 타입( `Int`, `Long`, , `Byte`) 은 `Short`양수와 음수 모두 가능합니다. 이러한 모든 정수 타입 외에도, Kotlin은 **부호 없는** 정수(음수가 아닌 값만 포함할 수 있는 정수)를 생성할 수 있는 기능을 제공합니다.

Kotlin은 다음과 같은 부호 없는 유형을 제공합니다.

|   |   |
|---|---|
|**유형**|**설명**|
|`UByte`|부호 없는 8비트 정수, 범위는 0~255입니다.|
|`UShort`|부호 없는 16비트 정수, 범위는 0~65535입니다.|
|`UInt`|부호 없는 32비트 정수, 범위는 0~4,294,967,295(2^32-1)입니다.|
|`ULong`|부호 없는 64비트 정수, 범위는 0~18,446,744,073,709,551,615(2^64-1)입니다.|

부호 없는 숫자는 다른 숫자와 동일한 방식으로 생성됩니다. 부호 없는 숫자를 생성한다는 것을 나타내려면 접미사 " `u`" 또는 " `U`"를 추가해야 합니다.

```kotlin
val uByte: UByte = 5u
val uShort: UShort = 10U
```

이 예제에서는 지정된 유형의 변수를 생성합니다. 하지만 유형을 직접 지정하지 않으면 컴파일러는 리터럴 크기에 따라 `UInt`또는 을 사용합니다.`ULong`

```kotlin
val smallSize = 100u // UInt by default
val bigSize = 5_000_000_000u // ULong because the number doesn't fit in UInt
```

`uL`특수 접미사 " " (또는 " ") 도 있습니다 `UL`. 이 접미사를 숫자에 추가하면 `ULong`숫자 크기에 관계없이 _가 생성됩니다.

```kotlin
val smallLong = 10uL // ULong because it is marked with "uL"
```

## 데이터 유형 오버플로

단항 빼기 연산을 제외하고, 부호 있는 자료형에 대한 모든 산술 연산은 부호 없는 자료형에서도 가능합니다.

다음 코드의 결과를 살펴보겠습니다.

```kotlin
// MAX_VALUE: Int = 2147483647
var d: Int = 2147483647
d += 1
println(d) // -2147483648
```

예상치 못한 결과. 이와 유사한 상황을 데이터 유형 오버플로라고 합니다. 이는 세부 사항이므로 지금 당장 파악할 필요는 없습니다. 무슨 일이 일어났는지 이해하기 위해, 물이 담긴 빈 컵을 상상해 보세요. 컵이 가득 차면 물이 가장자리를 넘어 넘칩니다. 변수에서도 같은 상황이 발생합니다. 변수 값이 경계값에 가까우면 결과 값이 변수에 할당된 메모리에 맞지 않을 위험이 있습니다. 변수 유형의 오버플로는 데이터 손실, 프로그램의 예기치 않은 동작 등을 초래합니다.

예제에서 오버플로가 발생한 이유를 알아보겠습니다. 타입 변수는 `Int`최댓값을 가집니다 `MAX_VALUE: Int = 2147483647`. 숫자가 최댓값보다 더 증가하면 어떻게 되는지 살펴보겠습니다. 컴퓨터는 1과 0만 사용한다는 점을 기억하세요. 컴퓨터의 경우, 숫자 2147483647은 다음과 같습니다.

```kotlin
2147483647 = 01111111111111111111111111111111
```

이 숫자에 1을 더하면 다음과 같은 결과가 나옵니다.

```kotlin
10000000000000000000000000000000 = -2147483648
```

모든 마법은 숫자의 왼쪽 비트가 1의 값을 갖고 숫자가 음수 값을 가질 때 일어납니다. 이 주제에 대해 더 자세히 알아보려면 [여기](https://hyperskill.org/learn/step/19917) , [여기](https://hyperskill.org/learn/step/5745) , 그리고 [여기를](https://hyperskill.org/learn/step/5753) 참조하세요. 이제 데이터 유형의 최댓값에 도달했을 때, 최댓값 바로 다음 값이 해당 유형의 최솟값이 될 것이라고 말할 수 있습니다. 이렇게 원을 그리며 반복됩니다.

다른 예를 살펴보겠습니다.

```kotlin
val c: Long = 1_000_000_000_000_000
println(c.toInt())
```

코드 실행 결과는 다음과 같습니다.

```no-highlight
-1530494976
```

`Long`이 예제에서는 변수를 에 넣으려고 했습니다 `Int`. 잘림 현상이 발생하여 숫자의 하위 비트는 그대로 유지되고 상위 비트는 손실되어 결과는 예측할 수 없습니다. 이러한 현상이 어떻게 발생하는지 살펴보겠습니다.

![Int의 Long 변수](https://ucarecdn.com/653efe3f-d247-4795-a1f2-9651bd5ac265/)

다음 사항을 기억하는 것이 중요합니다.

- 데이터 유형 오버플로 오류는 프로그래머 오류입니다.
    
- 데이터 유형 오버플로가 발생하는 경우 프로그램 동작은 예측할 수 없습니다.
    
- 컴파일러는 유형 오버플로에 대해 경고하지 않으므로 변수의 데이터 유형을 올바르게 선택하고 데이터 유형의 변환을 주의 깊게 모니터링해야 합니다.
    

## 결론

`Long`이 주제에서는 두 가지 기본 Kotlin 정수 타입인 과 를 살펴보고 `Int`입력에서 데이터를 읽는 방법을 알아보았습니다. 또한 [부호 없는 정수](https://hyperskill.org/learn/step/4488 "Kotlin에서 부호 없는 정수는 음수가 아닌 값만 포함할 수 있는 정수 유형입니다. | 양수와 음수가 모두 될 수 있는 일반 정수 유형(예: `Int` 및 `Long`)과 달리 부호 없는 정수는 항상 양수이거나 0입니다. Kotlin은 다음과 같은 부호 없는 유형을 제공합니다. `UByte`(0~255 범위의 부호 없는 8비트 정수), `UShort`(0~65535 범위의 부호 없는 16비트 정수), `UInt`(0~4,294,967,295 범위의 부호 없는 32비트 정수), `ULong`(0~18,446,744,073,709,551,615 범위의 부호 없는 64비트 정수). 부호 없는 숫자를 생성한다는 것을 나타내려면 리터럴에 접미사 `U` 또는 `u`를 추가해야 합니다. 부호 있는 타입에 대한 모든 산술 연산은 부호 없는 타입에서도 가능합니다.") 타입이 무엇인지도 알아보았습니다. 이제 데이터를 처리하는 프로그램을 작성할 수 있는 충분한 기술을 갖추게 되었습니다. 위의 템플릿을 사용하여 이 주제의 코드 문제를 해결할 수 있습니다. 변수에 의미 있는 이름을 지정하는 것이 매우 유용하므로 잊지 마세요.