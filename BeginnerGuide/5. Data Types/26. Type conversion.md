
```cardlink
url: https://hyperskill.org/learn/step/4672
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```



타입 변환 또는 타입 캐스팅은 값을 한 [데이터 타입](https://studio.hyperskill.org/learn/step/4672 "Kotlin에서 데이터 유형은 변수, 표현식 또는 함수 매개변수가 보유할 수 있는 값의 종류를 지정하는 분류입니다. | Kotlin과 같은 정적 타입 언어의 필수적인 측면으로, 변수와 함수 매개변수에 대한 명시적 또는 암시적 타입 선언이 필요합니다. 예를 들어 Kotlin에는 정수, 부동 소수점 숫자, 문자, 부울, 문자열과 같은 다양한 데이터 유형이 있습니다. 이 중 문자열은 큰따옴표로 묶인 0개 이상의 문자 시퀀스를 나타내는 널리 사용되는 데이터 유형입니다. 문자열은 조건문과 정규 표현식에서 자주 사용되며 길이를 얻거나 두 문자열을 연결하는 등 다양한 연산을 수행합니다. 또한, 타입 추론은 Kotlin의 유용한 기능으로, 컴파일러가 변수, 표현식 또는 함수 매개변수의 데이터 유형을 자동으로 추론하여 코드를 더 간결하고 읽기 쉽게 만듭니다.") 에서 다른 데이터 타입으로 변환하는 것을 포함합니다. Kotlin은 정적 타입 언어이기 때문에 이는 특히 중요합니다. 즉, 컴파일 타임에 타입이 식별되고 엄격하게 적용됩니다.

## 숫자형 간 변환

가장 일반적인 세 ​​가지 숫자 유형은 `Int`, `Long`, 입니다 `Double`. 경우에 따라 한 숫자 유형의 값을 다른 숫자 유형의 변수에 할당해야 할 수 있습니다. 이 경우 , , , 등과 같은 특수 함수를 호출하여 **유형 변환을 수행해야 합니다.**`toInt()``toLong()``toDouble()`

`num`이라는 타입의 변수가 있다고 가정해 보겠습니다 . 이 변수를 숫자의 제곱근을 구하는 `Int`함수 `sqrt()`(이 함수에 대한 자세한 내용과 사용 방법은 [여기를](https://hyperskill.org/learn/step/12532)`Double` 참조하세요)에 전달하려고 합니다. 이 함수는 대신 값을 필요로 하므로, **타입 불일치** 오류를 방지하기 위해 `Int`를 사용하여 값을 변환해야 합니다 .`toDouble()`

```kotlin
val num: Int = 100

val res: Double = sqrt(num.toDouble())
println(res) // 10.0

println(num) // 100, it is not modified
```

위의 예에서 변수 유형은 설명을 단순화하기 위해 지정되었습니다.

`toDouble()`변수의 타입을 수정하지 않습니다. 이 함수는 해당 `Double`타입의 새 값을 생성합니다.

대상 유형이 소스 유형보다 클 때 이러한 연산을 수행해야 한다는 점에 유의하세요. 예를 들어, . `Int`로 변환해야 합니다 `Long`. 이는 Kotlin을 Java나 C#과 같은 다른 프로그래밍 언어와 차별화하는 요소로, 추가 작업 없이 더 작은 유형의 숫자를 더 큰 유형의 변수에 할당할 수 있습니다.

```kotlin
val num: Int = 100
val bigNum: Long = num.toLong() // 100
```

`Char`숫자형은 아니지만, 문자 코드에 따라 숫자를 문자로, 또는 그 반대로 변환할 수 있습니다. 유니코드 표에서 해당 코드를 확인할 수 있습니다. 이 코드는 기본적으로 정수입니다.

```kotlin
val n1: Int = 125
val ch: Char = n1.toChar() // '}'
val n2: Int = ch.code      // 125
```

## Short 및 Byte 유형으로 변환

아시다시피, `Short`과 `Byte`타입은 매우 작습니다. 이러한 타입은 거의 사용되지 않으며, 정수를 저장해야 하는 경우에는 를 사용해야 합니다 `Int`. 왜 그래야 하는지 보여주는 예시는 다음과 같습니다.

일반적으로 함수를 사용하여 무언가를 이러한 타입으로 변환할 수 있습니다 `toShort()`. `toByte()`Kotlin 1.4부터는 변환 `Double`이나 `Float`타입 지정을 시도할 때 이러한 함수를 사용하지 않아야 합니다. 이 기능은 현재 릴리스에서 이미 제거되었습니다. 여기서 가장 큰 문제는 변수의 크기가 작아 변환 시 예상치 못한 결과가 발생할 수 있다는 것입니다. 이제 `Double`or `Float`를 or 로 변환한 `Int`후 결과를 `Short`or 로 변환해야 합니다 `Byte`.

```kotlin
val floatNumber = 10f
val doubleNumber = 1.0

val shortNumber = floatNumber.toShort() // avoid this
val byteNumber = doubleNumber.toByte()  // avoid this

val shortNumber = floatNumber.toInt().toShort() // correct way
val byteNumber = doubleNumber.toInt().toByte()  // correct way
```

## 문자열 변환

때로는 다른 타입의 값을 문자열로 변환해야 할 때가 있습니다. Kotlin은 `toString()`이를 위한 함수를 제공합니다. 모든 타입의 값을 문자열로 변환할 수 있습니다.

```kotlin
val n = 8     // Int
val d = 10.09 // Double
val c = '@'   // Char
val b = true  // Boolean

val s1 = n.toString() // "8"
val s2 = d.toString() // "10.09"
val s3 = c.toString() // "@"
val s4 = b.toString() // "true"
```

문자열은 숫자나 부울 값으로 변환될 수 있지만 단일 문자로는 변환될 수 없습니다.

```kotlin
val n = "8".toInt() // Int
val d = "10.09".toDouble() // Double
val b = "true".toBoolean() // Boolean
```

문자열 표현의 형식이 올바르지 않으면 오류가 발생합니다. 오류가 발생하면 특별한 조치를 취하지 않으면 프로그램이 중단됩니다. 이에 대해서는 나중에 자세히 설명하겠습니다.

하지만 문자열을 부울 값으로 변환하면 오류가 발생하지 않습니다. 문자열이 대소문자를 구분하지 않고 부울 값을 반환하면 부울 값을, 그렇지 않으면 1을 `"true"`반환합니다 .`true``false`

```kotlin
val b1 = "false".toBoolean() // false
val b2 = "tru".toBoolean()   // false
val b3 = "true".toBoolean()  // true
val b4 = "TRUE".toBoolean()  // true
```

## 유형 변환 문제

예를 들어, 부동 소수점 타입의 값이 있는 경우, 해당 값을 이나 와 `Double`같은 정수 타입의 값으로 변환할 수 있습니다 . 어떤 일이 일어나는지 확인해 보겠습니다.`Int``Long`

```kotlin
val d: Double = 12.5
val n: Long = d.toLong() // 12
```

보시다시피, 소수 부분은 그냥 삭제되었습니다. 따라서 결과는 나오지만 정확도가 다소 떨어집니다. 이 변환은 주의해서 사용하세요!

위에서 언급한 함수를 사용하여 큰 숫자형에서 작은 숫자형으로( `Long`또는 `Double`로 `Int`) 변환하려고 할 때 또 다른 문제가 발생할 수 있습니다. 값이 아주 작은 경우에는 문제없이 작동합니다.

```kotlin
val d: Double = 10.2
val n: Long = 15

val res1: Int = d.toInt() // 10
val res2: Int = n.toInt() // 15
```

그러나 이러한 변환을 수행하면 값이 잘릴 수 있으며, `Long`잘린 `Double`숫자보다 큰 숫자를 저장할 수 있습니다 `Int`.

```kotlin
val bigNum: Long = 100_000_000_000_000

val n: Int = bigNum.toInt() // 276447232; oops
```

결과적으로 잘린 값이 반환됩니다. 이 문제는 **타입 오버플로우** 라고 합니다. 또는 `Int`로 변환하려고 할 때도 같은 문제가 발생할 수 있습니다 . 따라서 더 큰 타입 값을 더 작은 타입 값으로 변환하려는 경우, 잘림으로 인해 프로그램이 제대로 작동하지 않도록 주의해야 합니다.`Short``Byte`

## 데모

아래 프로그램은 위에서 설명한 함수들을 보여줍니다. 숫자의 문자열 표현을 읽어 여러 다른 유형으로 변환한 다음, 모든 변환 결과를 출력합니다.

```kotlin
fun main() {
    val something = readln()

    val d = something.toDouble()
    val f = d.toFloat()
    val i = f.toInt()
    val b = i.toByte()

    println(d)
    println(f)
    println(i)
    println(b)
    println(something.toBoolean())
}
```

다음과 같은 입력이 있다고 가정해 보겠습니다.

```kotlin
1000.0123456789
```

프로그램은 다음을 출력합니다.

```kotlin
1000.0123456789
1000.0123
1000
-24
false
```

출력을 자세히 살펴보겠습니다. 문자열로 표현된 숫자는 `Double`적절한 형식을 갖기 때문에 로 성공적으로 변환되었습니다. 이 숫자는 `Double`안전하게 타입으로 저장할 수 있습니다. 그런 다음 숫자는 로 변환됩니다 `Float`. 여기서 손실이 발생하는 것을 볼 수 있는데, 이 타입은 저장할 수 있는 소수 자릿수가 더 적기 때문입니다. `Int`변환 과정에서 소수 부분이 잘립니다. 숫자 1000은 `Byte`타입이 저장할 수 있는 값(-128에서 127)보다 크기 때문에 타입 오버플로(-24)가 발생합니다. 입력 문자열을 로 변환한 결과는 `Boolean`입니다 `false`. 값이 이므로 `"true"`(대소문자 구분 없음) 입니다.

## 결론

이제 기본 데이터 유형 간 변환 원리를 이해했습니다. 숫자 변환은 다양한 숫자 유형 간에 값을 변환해야 할 때 유용합니다. Kotlin에서는 대상 크기 유형과 소스 크기 유형이 다르더라도 특수 함수( `toInt()`, `toLong()`, `toDouble()`)를 호출하여 숫자를 변환할 수 있습니다. 문자열 변환은 특정 값의 문자열 표현을 얻어야 할 때 유용합니다. `toString()`함수를 사용하여 수행할 수 있습니다. 유형 변환은 필수적이고 매우 유용하지만, 유형 오버플로와 정밀도 손실에 유의해야 합니다!