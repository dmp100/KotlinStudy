
```cardlink
url: https://hyperskill.org/learn/step/11801
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


난수는 주사위를 던졌을 때 나오는 결과처럼 예측이 거의 불가능한 숫자입니다. 난수 생성기는 필요할 때, 그리고 아마도 꽤 자주 필요할 때 이러한 숫자를 제공할 수 있습니다. 예를 들어, 아무도 추측할 수 없는 비밀번호를 만들거나, 게임에서 예측 불가능한 다음 수를 두거나, 많은 양의 무작위 데이터를 생성할 때 유용합니다.

난수 생성기는 암호화, 머신러닝, 게임 등 다양한 분야에서 널리 사용됩니다. 이 주제에서는 Kotlin에서 난수를 생성하는 몇 가지 방법을 살펴보겠습니다.

## 난수의 종류

특정 유형을 선택하여 난수에 몇 가지 제한을 설정할 수 있습니다. 이 목적에 필요한 모든 것은 패키지에 포함되어 있습니다 `kotlin.random`. 아래 코드 조각을 살펴보세요.

```kotlin
import kotlin.random.Random

fun main() {
    // generates an integer value between Int.MIN_VALUE and Int.MAX_VALUE (inclusive)
    println( Random.nextInt() ) 
    // generates a long value between Long.MIN_VALUE and Long.MAX_VALUE (inclusive).
    println( Random.nextLong() ) 
    // generates a float value between 0 (inclusive) and 1.0 (exclusive)
    println( Random.nextFloat() )
    // generates a double value between 0 (inclusive) and 1.0 (exclusive)
    println( Random.nextDouble() )
    // same thing one more time
    println( Random.nextDouble() )
}
```

이 코드는 주어진 유형의 난수를 생성합니다.

```kotlin
-1272462740
8641728355635965765
0.036410034
0.9411751338804492
0.2533641025032649
```

다시 실행하면 마지막 두 숫자에서 볼 수 있듯이 숫자가 달라집니다. 같은 `nextDouble()`함수를 호출했지만 숫자가 같지는 않습니다. 생성기가 매번 새로운 숫자를 생성하기 때문입니다. 때로는 반복될 수도 있지만, 그럴 확률은 매우 낮습니다.

## 사용자 정의 범위

보시다시피, 어떤 숫자는 꽤 크고, 어떤 숫자는 작으며, 심지어 어떤 숫자는 음수입니다. 정수와 [부동 소수점 숫자](https://hyperskill.org/learn/step/11801 "코틀린에서 부동 소수점 숫자는 높은 정밀도로 실수를 표현할 수 있는 숫자 유형입니다. | 'double' 키워드로 표현되는 64비트 데이터 유형으로, 양수와 음수를 포함한 다양한 십진수 값을 저장할 수 있습니다. 부동 소수점 숫자는 십진수 값을 포함하는 수학 연산에 필수적입니다. 프로그래밍에서 실수를 표현하는 데 사용되며, 코틀린에서 'Int' 유형으로 표현되는 정수와는 다릅니다.") 의 기본 범위는 서로 다르며 가장 일반적인 경우를 포괄하도록 선택되었습니다. 하지만 0에서 100 사이의 정수 또는 0.0에서 5.0 사이의 부동 소수점만 필요하다면 어떻게 해야 할까요? 그러면 다음과 같이 명시적으로 지정할 수 있습니다.

```kotlin
// generates a non-negative integer value less than 100 
Random.nextInt(100) 
// generates an integer value between 1 (inclusive) and 100 (exclusive)
Random.nextInt(1, 100) 

// generates a non-negative long value less than 100
Random.nextLong(100)
// generates a long value between 1 (inclusive) and 100 (exclusive)
Random.nextLong(1, 100) 
 
// generates a non-negative double value less than 5.0 
Random.nextDouble(5.0) 
// generates a double value between 0.0 (inclusive) and 5.0 (exclusive)
Random.nextDouble(0.0, 5.0) 
```

이제 음수가 없고, 모든 정수는 100보다 작으며, 일부 부동 소수점은 1.0보다 크다는 것을 확신할 수 있습니다.

```kotlin
 36
 41
 12
 53
 0.00709856968715783
 2.8675389664207414
```

`nextFloat`사용자 지정 범위를 지정할 수 없는 유일한 함수는 이 함수입니다. 이 함수 는 `nextDouble`더 나은 정밀도를 제공하므로 대신 이 함수를 사용합니다.

## 의사난수와 시드

그렇다면 왜 이 함수들이 호출 `next[......]`되고 호출되지 않을까요 `get[.....]`? 함수가 호출될 때마다 미리 정의된 시퀀스의 다음 숫자를 반환합니다. 이 숫자들을 **의사난수** 라고 하며 , 완전히 예측 불가능한 것은 아닙니다! 초기값과 시퀀스의 알고리즘을 알고 있다면 모든 숫자를 계산할 수 있습니다. 이 초기값을 **시드** 라고 합니다 . 시드 자체는 `next[......]`함수에서 반환되지 않지만, 이후의 모든 숫자를 정의합니다.

알고리즘이 동일하기 때문에 동일한 Kotlin 런타임 버전을 사용하면 동일한 시드가 동일한 시퀀스를 생성한다는 것이 보장됩니다. 이는 난수 생성기를 사용하는 코드를 안정적으로 테스트하는 데 유용할 수 있습니다.

시드가 42인 시퀀스에서 5개의 의사난수를 생성해 보겠습니다.

```kotlin
val randomGenerator42 = Random(42) // the generator takes the seed
for (i in 0..5) {
    randomGenerator42.nextInt(100)
}
```

Kotlin 1.4에서 이 코드는 다른 컴퓨터에서도 항상 동일한 6개의 숫자를 생성합니다 `33, 40, 41, 2, 41, 32`. 반면, 기본 생성기는 매번 새로운 시퀀스를 생성합니다.

```kotlin
// the same generator we use when we call Random.nextInt(), Random.nextFloat() etc.
val defaultGenerator = Random.Default 
for (i in 0..5) {                      
    defaultGenerator.nextInt(100)
}
```

## 결론

의사난수 데이터를 사용하려면 예측 가능한 결과가 필요한지 여부를 결정해야 합니다. 첫 번째 경우에는 알려진 시드를 사용할 수 있고, 두 번째 경우에는 시스템 시간을 기준으로 시드를 생성하거나 기본 구현을 사용할 수 있습니다. 난수 시퀀스는 동일한 Kotlin 런타임 버전을 사용하여 생성된 경우에만 동일하다는 것이 보장되지만, Kotlin 버전이나 프로그래밍 언어에 따라 같은 시드를 사용하더라도 결과가 다를 수 있습니다.