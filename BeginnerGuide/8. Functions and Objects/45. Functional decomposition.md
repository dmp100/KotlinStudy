
```cardlink
url: https://hyperskill.org/learn/step/12668
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


Kotlin으로 간단한 함수를 만드는 방법은 이미 알고 계실 겁니다. 이는 코드를 더 짧게 만들고, 가독성을 높이며, 이전에 작성한 코드의 일부를 재사용할 수 있게 해 주는 매우 유용한 기술입니다.

프로그래밍 작업이 점점 더 복잡해짐에 따라 함수도 점점 더 복잡해집니다. 하나의 견고한 함수 또는 `main`함수 하나로 래핑된 복잡한 프로그램을 만들 수도 있지만, 프로그램을 읽고 이해하기 쉬운 더 구체적인 부분으로 나누는 것이 더 좋습니다. 복잡한 프로그램을 여러 함수로 나누는 접근 방식을 **함수 분해** 라고 합니다 .

이 주제에서는 특정 문제의 솔루션을 여러 개의 함수로 분해하는 방법을 살펴보겠습니다.

## 복잡한 작업 해결

큰 문제를 여러 개의 하위 문제로 분해한다는 아이디어는 매우 직관적입니다. 피자를 굽고 싶다면, 모든 재료를 오븐에 넣는 것이 아니라, 반죽부터 실제 요리까지 과정을 여러 개의 작업으로 나눕니다. 함수 분해는 피자를 굽는 것과는 다르지만, 큰 문제를 함수와 관련된 작은 조각들로 분해하는 것과 같은 원리에 기반합니다.

예를 들어 보겠습니다. 스마트 홈 앱을 시뮬레이션하는 프로그램을 생각해 보세요. 이 앱은 무선 스피커 시스템, 조명, 홈 시큐리티, 도어락, 심지어 로봇까지 원격으로 접근할 수 있는 홈 기기를 제어하는 ​​데 사용됩니다. 음악 켜기/끄기, 조명 켜기/끄기, 도어락 제어 등 세 가지 동작을 수행할 수 있는 간단한 스마트 홈 앱이 있다고 가정해 보겠습니다. 이러한 동작들을 컴퓨터 프로그램의 일부로 생각해 보겠습니다.

스마트 홈 앱을 작동하는 일반적인 알고리즘은 다음 단계로 나눌 수 있습니다.

1. 입력 데이터(입력된 비밀번호)를 구문 분석합니다.
    
2. 비밀번호가 올바른지 확인하세요.
    
3. 사용자에게 무엇을 하고 싶은지 물어보세요.
    
4. 해당 작업이 지원되는 경우 수행합니다.
    

이 프로그램을 코드로 감싸고, 추가 함수는 하나도 넣지 않았다고 상상해 보세요. 프로그램의 구조는 다음과 같습니다.

```kotlin
fun main() {
    // ...
    val password = "76543210"
    var speakersState: String
    var lampState: String
    var doorState: String
    // ...

    // reading the password
    println("Enter password: ")
    val passwordInput = readln()

    // checking if the password is correct
    if (passwordInput != password) {
        println("Incorrect password!")
    } else {
        // asking the user what they want to do
        println("Choose the object: 1 – speakers, 2 – lamp, 3 – door")
        val action = readln()

        when (action) {
            "1" -> {
                // asking the user about the speakers
                when (speakersState) {
                    "on" -> {
                        // ...
                    }
                    "off" -> {
                        // ...
                    }
                    else -> {
                        // ...
                    }
                }
            }
            "2" -> {
                // asking the user about the lights...
            }
            "3" -> {
                // asking the user about the door...
            }
            else -> {
                // ...
            }
        }
    }
}
```

실제 프로그램의 축약된 버전을 보더라도 코드는 여전히 오버로드된 것처럼 보입니다. 하지만 이 코드는 우리가 겪고 있는 문제에는 완벽하게 작동하며, 그대로 둘 수도 있습니다. 하지만 나중에 필요에 따라 수정하거나 기능을 확장할 수도 있습니다.

이 코드를 여러 사용자에게 적용하고 싶다면 어떻게 해야 할까요? 아니면 동작 수를 늘리고 더 복잡하게 만들고 싶다면 어떻게 해야 할까요? 코드의 일부는 여전히 사용되고, 일부는 삭제될 가능성이 높습니다. 이 코드를 덜 구체적이고 더 유연하게 만들기 위해 함수 분해를 사용할 수 있습니다.

## 프로그램을 함수로 분해하기

**함수 분해는** 문제를 여러 함수로 분해하는 과정입니다. 각 함수는 특정 작업을 수행하며, 필요한 결과를 얻기 위해 연속적으로 수행할 수 있습니다. 문제를 고려할 때, 여러 번 반복되거나 개별적으로 수행될 작업을 파악해야 합니다. 이를 통해 읽고, 이해하고, 재사용하고, 테스트하고, 디버깅하기 쉬운 원하는 함수를 얻을 수 있습니다.

스마트 홈 앱을 다시 살펴보고 어떤 단계를 별도의 기능으로 전환할 수 있는지 알아보겠습니다. 먼저, 사용자 동작을 분리하여 해당 기능을 만들 수 있습니다. 하나는 음악 제어, 다른 하나는 조명 켜고 끄기, 그리고 세 번째는 도어락 작동입니다.

`controlMusic()`음악을 제어하는 ​​함수를 살펴보세요 . 함수 `controlLight()`와 `controlDoor()`알고리즘은 동일합니다.

```kotlin
// turns the music on and off
fun controlMusic() {
    println("on/off?")
    val tumbler = readln()
    when (tumbler) {
        "on" -> println("The music is on")
        "off" -> println("The music is off")
        else -> println("Invalid operation")
    }
}
```

이러한 제어 기능은 앱에서 제공하는 주요 작업을 수행합니다. 작업 내용은 크게 단순화되었으며, 기능 수정 과정을 설명하는 데에만 사용됩니다.

분리할 수 있는 또 다른 기능은 비밀번호 검사기입니다.

```kotlin
// verifies the password and gives the access to Smart home actions if the password is correct
fun accessSmartHome() {
    val password = "76543210"
    print("Enter password: ")
    val passwordInput = readln()
    if (passwordInput == password)
        chooseAction()
    else
        println("Incorrect password!")
}
```

`chooseAction()`또한 사용자가 원하는 동작을 선택할 수 있는 메뉴 기능을 만들었습니다 . 이 기능은 사용자에게 어떤 동작을 수행할지 묻고 해당 기능에 대한 제어권을 부여합니다.

`main`마지막으로, 프로그램이 시작되면 호출되는 함수 에서 분해된 프로그램을 실행할 수 있습니다 .

```kotlin
fun main() {
    accessSmartHome()
}
```

이 함수는 `accessSmartHome`사용자에게 비밀번호를 입력하도록 요청하고, 비밀번호가 맞으면 스마트 홈을 관리할 수 있도록 하는 함수를 호출합니다.

## 새로운 기능 추가

이제 다른 동작을 추가하려면 해당 함수를 정의하기만 하면 됩니다. 예를 들어, 새로운 스마트 기기인 전기 주전자가 있다고 가정해 보겠습니다. 이 기기를 켜고 끄는 함수를 만듭니다. 새 함수에 접근하려면 `chooseAction()`사용 가능한 새 동작 값을 추가하여 함수를 수정해야 합니다.

```kotlin
// controls electric kettle
fun controlKettle() {
    // ...
}

// main menu for choosing the action
fun chooseAction() {
    // ...

    // adding new action 4
    println("Choose the object: 1 – speakers, 2 – lamp, 3 – door, 4 – kettle")
    // ...
        "4" -> controlKettle()
    // ...
}
```

보시다시피, 이제 조금만 수정해도 제대로 작동하는 프로그램이 완성되었습니다. 각 구성 요소가 별도의 함수로 정의되어 있으므로 각 구성 요소를 쉽게 테스트할 수 있습니다. 이는 향후 프로그램 지원에도 도움이 됩니다.

## 관용구

이미 알고 계시겠지만, `if`와 는 `when`표현식으로 사용할 수 있습니다. 따라서 코드를 단순화하는 한 가지 확실한 방법은 표현식 형식을 사용하는 것입니다. 간단한 함수에서는 이 형식을 사용하는 것이 좋습니다.

```kotlin
fun transform(color: String): Int { // you can miss one of the returns
    when (color) {
        "Red" -> return 0
        "Green" -> return 1
        "Blue" -> return 2
        else -> return -1    
    }
}
fun transform(color: String): Int { // you can accidentally change the variable `colorNumber` 
    var colorNumber = -1
    when (color) {
        "Red" -> colorNumber = 0
        "Green" -> colorNumber = 1
        "Blue" -> colorNumber = 2
    }
    return colorNumber
}

fun transform(color: String): Int { // nice and concise code
    return when (color) {
        "Red" -> 0
        "Green" -> 1
        "Blue" -> 2
        else -> -1    
    }
}
```

또한, 단일 표현식 함수에서 이 관용구를 사용할 수 있습니다.

```kotlin
fun transform(color: String) = when (color) {
    "Red" -> 0
    "Green" -> 1
    "Blue" -> 2
    else -> -1    
}
```

짧은 형태의 표현식도 있습니다 `if`. 다음과 같이 짧은 함수를 작성해 보세요.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

보시 `when`다시피 표현식은 내용을 명확하게 유지하고 데이터 손실을 방지하는 데 도움이 됩니다. 코드를 작성할 때 [이 관용구 를 활용해 보세요.](https://kotlinlang.org/docs/idioms.html#return-on-when-statement)

## 결론

함수 분해는 매우 유용한 프로그래밍 방식으로, 다음과 같은 작업에 도움이 됩니다.

- 코드를 구조화하여 더 읽기 쉽고 이해하기 쉽게 만듭니다.
    
- 코드를 쉽게 수정하세요.
    
- 함수를 재사용하여 코드를 간결하게 만듭니다.
    
- 구성 요소를 개별적으로 테스트하여 테스트 과정을 더욱 편리하게 만드세요.
    

물론 함수 분해가 보편적인 해결책은 아니지만, 사용하기 쉽고 깔끔하고 이해하기 쉬운 프로그램을 만드는 데 도움이 될 수 있습니다.