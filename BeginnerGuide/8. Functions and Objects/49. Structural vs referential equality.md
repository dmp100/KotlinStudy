
```cardlink
url: https://hyperskill.org/learn/step/11236
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


객체는 매우 복잡한 구조이고 변수는 객체만을 가리킨다는 것을 이미 알고 계실 겁니다. 이번에는 동등성과 변수가 같은 객체를 가리킨다는 것을 이해하는 방법을 배우게 될 것입니다. 또한, `val` [키워드](https://hyperskill.org/learn/step/11236 "코틀린에서 키워드는 언어 내에서 특별한 의미를 갖는 단어로, 프로그래머가 변경할 수 없습니다. | 코드의 구조와 동작을 정의하는 데 사용됩니다. 코틀린에서 키워드의 예로는 `fun` (함수 정의), `var` (변수 정의), `if` (조건문 정의) 등이 있습니다. 키워드는 코틀린에서 예약어이므로 식별자로 사용할 수 없습니다.") 의 의미를 완전히 이해 하고, 초보자들이 가장 흔히 저지르는 실수 중 하나인 `val`키워드가 불변성을 보장한다고 가정하는 것을 피할 수 있을 것입니다.

## 비교

친구로부터 똑같은 메시지 두 개를 받았다고 상상해 보세요. 메시지는 "안녕"과 "안녕"입니다. 메시지를 보고 두 메시지가 같다는 것을 알게 됩니다. 코틀린에서 두 메시지를 비교하려면 문자열 값으로 저장할 수 있습니다.

```kotlin
val msg1 = "Hi"
val msg2 = "Hi"
```

그런 다음 비교 연산자 를 사용할 수 있습니다 `==`. 예를 들어, `print(msg1 == msg2)`와 `true`는 `print(msg1 == "Hello")`를 제공합니다 `false`. 변수 `msg1`와 는 `msg2`동일한 상태를 가지는데, 이를 **[구조적 동치성](https://hyperskill.org/learn/step/11236 "코틀린에서 구조적 동등성은 변수의 내부 상태가 같은지 여부를 나타냅니다. | 두 변수의 값이 같은지 확인하는 데 사용되며, 두 변수가 같은 객체를 참조하는지 여부는 중요하지 않습니다. 이는 `==` 연산자를 사용하여 수행할 수 있습니다. 구조적 동등성은 두 변수가 메모리에서 같은 객체를 참조하는지 확인하는 참조 동등성과 다릅니다. 숫자나 문자열과 같은 변경 불가능한 객체는 값이 같을 때 구조적으로 같습니다. 그러나 변경 가능한 객체의 경우, 구조적 동등성은 비교 시점에 값이 같다는 것을 의미합니다.")** 이라고 합니다 . 또한, 연산자 를 사용하여 부등식을 확인할 수 있습니다 `!=`. 예를 들어, `print(msg1 != "Hello")`를 제공합니다 `true`.

일부 복잡한 [데이터 유형](https://hyperskill.org/learn/step/11236 "Kotlin에서 데이터 유형은 변수, 표현식 또는 함수 매개변수가 보유할 수 있는 값의 종류를 지정하는 분류입니다. | Kotlin과 같은 정적 타입 언어의 필수적인 측면으로, 변수와 함수 매개변수에 대한 명시적 또는 암시적 타입 선언이 필요합니다. 예를 들어 Kotlin에는 정수, 부동 소수점 숫자, 문자, 부울, 문자열과 같은 다양한 데이터 유형이 있습니다. 이 중 문자열은 큰따옴표로 묶인 0개 이상의 문자 시퀀스를 나타내는 널리 사용되는 데이터 유형입니다. 문자열은 조건문과 정규 표현식에서 자주 사용되며 길이를 얻거나 두 문자열을 연결하는 등 다양한 연산을 수행합니다. 또한, 타입 추론은 Kotlin의 유용한 기능으로, 컴파일러가 변수, 표현식 또는 함수 매개변수의 데이터 유형을 자동으로 추론하여 코드를 더 간결하고 읽기 쉽게 만듭니다.") 에는 연산자가 없을 수 있습니다 `==`. 이에 대해서는 나중에 설명하겠습니다. `Box`다음 예제에서는 이 연산자를 사용합니다.

**변경 가능한** 객체를 복사하는 예를 살펴보겠습니다 . 공을 보관하는 상자가 있고, 거기에 공 하나를 넣을 수 있다고 가정해 보겠습니다. `Box` 객체를 생성하고 복사한 후 원본 객체를 변경해 보겠습니다.

```kotlin
val blueBox = Box(3)          // box with 3 balls
val azureBox = blueBox 
println(blueBox == azureBox ) // true, it's a copy
blueBox.addBall()             // add a ball to the first box
println(blueBox == azureBox ) // true, the second box also contains 4 balls
```

첫 번째 상자를 변경하면 해당 상자의 복사본도 변경됩니다. 이는 `blueBox`와 가 같은 객체를 가리키기 때문입니다. 이를 어떻게 확인할 수 있을까요? **[참조 동등성을](https://hyperskill.org/learn/step/11236 "In Kotlin, referential equality refers to the concept that two variables point to the same object in memory. | This is different from structural equality, which checks if the inner state of the variables is equal. To check referential equality, you can use the `===` operator in Kotlin. It is important to note that referential equality does not imply structural equality, and vice versa. Additionally, the use of the `val` keyword in Kotlin only implies that a variable cannot be reassigned a new reference, but it does not guarantee immutability of the object itself.")**`azureBox` 확인하는 방법을 살펴보겠습니다 .**[](https://hyperskill.org/learn/step/11236 "코틀린에서 참조 동등성은 두 변수가 메모리에 있는 동일한 객체를 가리킨다는 개념을 의미합니다. | 이는 변수의 내부 상태가 같은지 확인하는 구조적 동등성과는 다릅니다. 참조 동등성을 확인하려면 코틀린에서 `===` 연산자를 사용할 수 있습니다. 참조 동등성은 구조적 동등성을 의미하지 않으며, 그 반대의 경우도 마찬가지입니다. 또한, 코틀린에서 `val` 키워드를 사용하면 변수에 새로운 참조를 재할당할 수 없음을 의미할 뿐, 객체 자체의 불변성을 보장하지는 않습니다.")**

## 참조 동등성

변수는 동일한 상태를 가질 수 있고, 동일한 객체를 가리킬 수 있다는 것을 알고 계실 겁니다. 두 경우 모두 를 **반환**`==` 합니다 . 하지만 Kotlin은 변수가 동일한 객체를 가리키는지 확인하는 `true`특수 연산자를 제공합니다 . 예를 들면 다음과 같습니다.`===`

```kotlin
val blueBox = Box(3)
val azureBox = blueBox 
val cyanBox = Box(3)
println(blueBox == azureBox)  // true
println(blueBox === azureBox) // true, azureBox points to the same object
println(blueBox == cyanBox)   // true
println(blueBox === cyanBox)  // false, cyanBox points to another object
```

따라서 와 `blueBox`는 같은 상태를 갖지만 서로 다른 객체를 가리킵니다. 이 경우 의 상태 를 `cyanBox`변경해도 는 동일하게 유지됩니다.`blueBox``cyanBox`

```kotlin
blueBox.addBall()
println(blueBox == cyanBox) // false
```

또한, 연산자 를 사용하여 참조 부등식을 확인할 수 있습니다 `!==`. 예를 들어, `print(blueBox !== cyanBox`)는 .을 반환합니다 `true`.

이 연산자의 또 다른 흥미로운 점은 `===`불변 객체의 동등성입니다. 다음 예를 살펴보겠습니다.

```kotlin
var two = 2
var anotherTwo = 2
println(two === anotherTwo) // true
```

이 변수들은 같은 객체를 가리킵니다! 이 점은 걱정하지 마세요. 아시다시피 [불변](https://hyperskill.org/learn/step/11236 "코틀린에서 불변 변수는 초기화되면 변경할 수 없는 객체 또는 변수 유형입니다. | 이는 데이터 무결성을 보장하고 의도치 않은 수정을 방지하는 데 도움이 됩니다. 예를 들어, 책의 페이지 목록은 불변 컬렉션일 수 있으며, 시간이 지나도 내용이 변경될 수 없습니다. 반면, 가변 컬렉션은 저장된 항목을 추가, 제거 또는 업데이트하는 등의 변경을 허용합니다. `val` 키워드를 사용하여 선언된 불변 변수는 외부 코드에서 수정할 수 없으므로 안전하고 제어된 방식으로 내부 상태를 노출하는 데 특히 유용합니다.") 객체는 변경할 수 없습니다. 따라서 변수에 어떤 작업을 하려고 하면 해당 변수는 새 객체를 가리키고 다른 변수들은 여전히 ​​이전 객체를 가리킵니다. 다음을 변경해 보세요 `two`.

```kotlin
two++
println(two)        // 3
println(anotherTwo) // 2
```

따라서 변경 불가능한 객체는 매우 유용하며 복사 시 발생할 수 있는 많은 문제를 피하는 데 도움이 됩니다.

## 기본 유형 및 동등성

Kotlin의 객체에 대해서는 이미 꽤 잘 알고 계실 겁니다. 텍스트와 숫자 데이터를 많이 다루셨으니까요. 많은 프로그래밍 언어에서 기본 데이터 유형(primitives _)_ 은 가장 자주 사용되는 단순 데이터 유형을 저장합니다. 이러한 기본 데이터 유형의 내부 구조는 고유한 방식으로 구성됩니다. 하지만 Kotlin에서는 그렇지 않습니다. 짐작하셨겠지만, Kotlin에서 익숙한 `Int`, `String`, , `Float`, 는 `Double`객체입니다! 하지만 미묘한 차이가 있습니다. 예를 들어, `Int`또는 `String`변수는 다른 프로그래밍 언어의 기본 데이터 유형과 동일하게 동작하지만, 동시에 객체, 즉 불변 객체입니다. 작동 방식을 살펴보겠습니다.

```kotlin
var a: Int = 100
val anotherA: Int = a
println(a == anotherA)  // true
println(a === anotherA) // true
a = 200
println(a == anotherA)  // false
println(a === anotherA) // false
```

보시다시피 변수의 값을 변경해 `a = 200`도 객체는 변경되지 않습니다. 변수에는 `a`값이 있는 객체에 대한 새 참조가 할당됩니다 `200`.

한 가지 예를 살펴보겠습니다. 이번에는 `Double`데이터 유형을 살펴보겠습니다.

```kotlin
var d1: Double = 1.5
val d2 = d1
println(d1 === d2) // true
d1 += 1            // d1 is 2.5 now
println(d1 === d2) // false
```

보시다시피, 이러한 불변 객체의 동작은 동일합니다. 이제 수정 가능한 객체의 예를 살펴보겠습니다.

```kotlin
val list1: MutableList<Int> = mutableListOf()
val list2: MutableList<Int> = list1
list1.add(1)
println("list1 $list1") // list1 [1]
println("list2 $list2") // list2 [1]
list2.add(5)
println("list1 $list1") // list1 [1, 5]
println("list2 $list2") // list2 [1, 5]
```

이 예에서 볼 수 있듯이 변수 `list1`와 변수는 `list2`동일한 객체를 참조합니다. 첫 번째 변수를 통해 객체를 변경하면 두 번째 변수를 통해 업데이트된 데이터를 볼 수 있습니다.

## 결론

주제의 주요 내용을 다시 한번 살펴보겠습니다.

- 변수의 구조적 동등성은 내부 상태의 동등성을 의미합니다.
    
- 연산자 `==`와 를 사용하여 `!=`구조적 동일성을 확인할 수 있습니다.
    
- 변수의 참조적 동일성은 이러한 변수가 동일한 객체를 가리킨다는 것을 의미합니다.
    
- 참조 동일성을 확인하려면 연산자 `===`와 연산자를 사용할 수 있습니다 .`!==`
    
- 키워드 `val`는 변수를 재할당할 수 없다는 것을 의미하며, 불변성을 의미합니다.