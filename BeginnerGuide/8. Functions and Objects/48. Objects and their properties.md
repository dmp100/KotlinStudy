

```cardlink
url: https://hyperskill.org/learn/step/11233
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


우리 삶에서 우리는 항상 객체에 둘러싸여 있습니다. 자동차를 운전하고, TV를 보고, 책을 읽고, 스마트폰으로 바나나를 사 먹는 것처럼요. 코틀린에서는 변수를 사용할 때마다 객체를 사용합니다. 예를 들어, 정수 5와 문자열 "love"는 객체입니다. 프로그래머도 사람이고, 사람들은 객체를 다루는 데 익숙하기 때문에 편리합니다. 이 주제에서는 객체의 내부 구조, 상태와 동작, 그리고 고유한 특징에 대해 알아보겠습니다.

## 상태와 행동

객체는 데이터를 저장하고 특정 작업을 수행할 수 있는 복잡한 구조입니다. 객체를 얻는 방법은 무엇일까요? 객체는 어떤 정보를 저장하는 메모리의 일부입니다. 변수와 값은 객체를 가리킬 뿐입니다. 따라서 변수를 사용하여 객체를 다룰 수 있습니다. 객체의 간단한 예로 `String`메시지를 저장하는 객체가 있습니다. 자세히 살펴보겠습니다.

우선, 메시지에는 **상태가** 있습니다 . 상태는 심볼 시퀀스뿐만 아니라 시퀀스의 크기, 즉 메시지의 길이도 포함합니다. 코틀린에서는 객체의 상태에 접근할 수 있도록 하는 것을 **속성(property)** 이라고 합니다 . 객체 뒤에 점을 찍고 속성 이름을 적기만 하면 원하는 결과를 얻을 수 있습니다! 간단한 `String`변수 `msg`: 가 있다고 가정해 보겠습니다 `val msg = "Hi"`. length 속성은 문자열의 길이를 알려줍니다.

```kotlin
val msg = "Hi"
println(msg.length) // 2
```

코틀린에서 일부 **함수는** 특정 타입에 바인딩됩니다. 함수는 해당 객체의 동작을 나타내므로 객체를 사용하는 것이 더 논리적입니다. 이러한 함수는 **[멤버 함수](https://hyperskill.org/learn/step/11233 "코틀린에서 멤버 함수는 클래스 내에서 선언되어 같은 클래스에 속하는 객체 집합에 대해 공통된 동작을 구현하는 함수입니다. | 클래스의 특정 객체에 대해 동작하고 해당 객체의 필드에 접근할 수 있기 때문에 멤버 함수라고 합니다. 'this' 키워드는 클래스의 현재 인스턴스를 나타내며 멤버 함수를 호출하는 데 사용됩니다.")** 또는 **메서드** 라고도 합니다 . 구문은 비슷합니다. 마침표만 찍으면 됩니다. 예를 들어, 멤버 함수를 사용하여 메시지를 반복할 수 있습니다 `repeat()`.

```kotlin
val msg = "Hi"
println(msg.repeat(3)) // "HiHiHi"
```

인쇄할 내용:

```kotlin
HiHiHi
```

보시다시피, 표준형 `String`조차도 정말 복잡한 내부 구조를 가지고 있습니다.

## 참조로 복사

프로그래밍에서 무언가를 복사하는 것은 매우 흔한 작업입니다. `=`거의 모든 경우에 사용됩니다. 은행 계좌에 대한 간단한 비유를 통해 코틀린에서 복사가 어떻게 작동하는지 살펴보겠습니다.

한 계좌에 여러 개의 카드가 연결되어 있을 수 있습니다. 이러한 카드 중 하나로 물건을 사면 카드 종류가 달라도 여전히 해당 은행 계좌에서 돈을 쓰게 됩니다.

Kotlin에서도 비슷한 규칙이 적용됩니다. 변수를 생성하고 객체를 할당하면 다른 변수도 같은 객체를 가리킬 수 있습니다. 예를 들어 다음과 같은 문자 메시지를 작성했다고 가정해 보겠습니다.

```kotlin
val msg1 = "Hi"
val msg2 = msg1
```

단일 객체 "Hi"를 가리키는 두 개의 값이 있습니다.

![단일 객체를 가리키는 두 변수 msg1과 msg2](https://ucarecdn.com/40d6c4df-d493-45fe-ac57-0dd10e321d28/)

즉, `=`기호는 객체 자체를 복사하지 않고, 객체에 대한 참조만 복사합니다.

## 가변성

여러 변수에 할당된 객체를 이러한 변수 중 하나의 값을 변경하여 변경하면 어떻게 될까요? 이는 객체의 유형에 따라 다릅니다. 객체는 **변경 가능(mutable)** 하거나 **[변경 불가능(immutable)](https://hyperskill.org/learn/step/11233 "코틀린에서 불변 변수는 초기화되면 변경할 수 없는 객체 또는 변수 유형입니다. | 이는 데이터 무결성을 보장하고 의도치 않은 수정을 방지하는 데 도움이 됩니다. 예를 들어, 책의 페이지 목록은 불변 컬렉션일 수 있으며, 시간이 지나도 내용이 변경될 수 없습니다. 반면, 가변 컬렉션은 저장된 항목을 추가, 제거 또는 업데이트하는 등의 변경을 허용합니다. `val` 키워드를 사용하여 선언된 불변 변수는 외부 코드에서 수정할 수 없으므로 안전하고 제어된 방식으로 내부 상태를 노출하는 데 특히 유용합니다.")** 할 수 있습니다 .

`Int`코틀린에서 , `String`, , `Float`, 는 객체라는 것을 이미 알고 계실 겁니다 `Double`. 하지만 미묘한 차이가 있습니다. 예를 들어, `Int`또는 `String`변수는 다른 프로그래밍 언어의 기본 데이터 유형과 동일하게 동작하지만, 동시에 객체, 즉 변경할 수 없는 객체입니다. 작동 방식을 살펴보겠습니다.

```kotlin
var a: Int = 100
val anotherA: Int = a
println(a == anotherA)  // true
println(a === anotherA) // true
a = 200
println(a == anotherA)  // false
println(a === anotherA) // false
```

보시다시피 변수의 값을 변경해 `a = 200`도 객체는 변경되지 않습니다. 변수에는 `a`값이 있는 객체에 대한 새 참조가 할당됩니다 `200`.

한 가지 예를 살펴보겠습니다. 이번에는 `Double`데이터 유형을 살펴보겠습니다.

```kotlin
var d1: Double = 1.5
val d2 = d1
println(d1 === d2) // true
d1 += 1            // d1 is 2.5 now
println(d1 === d2) // false
```

객체가 불변이면 변경할 수 없지만, 다른 객체를 사용하여 이 새 객체를 같은 변수에 할당할 수 있습니다. 변수를 재할당하면 새 객체를 가리키게 되지만, 다른 변수는 여전히 이전 객체를 가리킵니다. 문자열이나 숫자와 같은 기본 타입은 불변이므로 참조로 복사해도 안전합니다.

## 결론

주제의 주요 내용을 요약해 보겠습니다.

- 객체는 상태, 속성, 멤버 함수를 갖춘 복잡한 구조입니다.
    
- 객체는 무언가를 저장하는 메모리의 일부입니다.
    
- 변수는 객체만을 가리킵니다.
    
- 객체는 변경 가능하거나 변경 불가능할 수 있습니다.
    
- 변경 불가능한 객체에 바인딩된 변수의 내용을 변경하는 유일한 방법은 변수를 다시 할당하는 것입니다.
    
- [기본 유형](https://hyperskill.org/learn/step/11233 "Kotlin에서 기본 유형은 언어 내에서 데이터 조작을 위한 기본적인 구성 요소입니다. | 이러한 유형은 의미에 따라 여러 그룹으로 구분할 수 있으며, 같은 그룹의 유형은 비슷하게 작동하지만 크기가 다르므로 값 범위도 다릅니다. Kotlin은 정수 및 분수에 대한 여러 유형을 제공합니다. 정수(예: int, long, short, byte)는 가장 큰 것부터 가장 작은 것까지 다음 네 가지 유형으로 표현됩니다. 이러한 유형은 크기가 다르므로 값 범위도 다를 수 있습니다. 정수 유형 범위는 - (2^(n-1))에서 (2^(n-1)-1로 계산할 수 있으며, 여기서 n은 유형의 비트 수입니다. 기본 유형은 상대적인 용어이므로 주어진 유형이 둘 중 하나일 필요는 없습니다. 이 경우 Exception 및 Error와 같은 유형의 하위 유형은 애플리케이션 내부의 예외 이벤트를 처리합니다.") 과 같은 변경 불가능한 객체를 자유롭게 복사할 수 있습니다 .