
```cardlink
url: https://hyperskill.org/learn/step/10622
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


아시다시피 예외는 프로그램의 정상적인 실행을 방해합니다. 일반적으로 이런 일은 원하지 않습니다. 다행히도 전체 프로그램을 중단하지 않고도 [예외를 처리 하는 코드를 작성할 수 있습니다.](https://hyperskill.org/learn/step/10622 "코틀린에서 예외 처리란 프로그램 실행 중 예외를 처리하고 대응하는 과정을 의미합니다. | 이 작업은 `try` 및 `catch` 키워드를 사용하여 수행됩니다. `try` 블록에는 예외를 발생시킬 수 있는 코드가 포함되어 있고, `catch` 블록에는 예외 발생 시 수행할 작업이 포함되어 있습니다. `try` 블록에서 예외가 발생하면 런타임 시스템은 처음부터 시작하여 해당 예외를 처리할 첫 번째 적합한 `catch` 블록을 결정합니다. 예외를 기반으로 올바른 결정을 내릴 수 있는 충분한 정보가 있는 메서드에서 예외를 처리하는 것이 가장 좋습니다.")

이를 위해 Kotlin에는 **[예외 처리](https://hyperskill.org/learn/step/10622 "Kotlin에서 예외 처리란 프로그램 실행 중 발생하는 예외나 오류를 관리하고 대응하는 프로세스를 말합니다. | 일반적으로 `try-catch` 문을 사용하여 처리하는데, `try` 블록에는 예외를 발생시킬 수 있는 코드가 포함되고, `catch` 블록에는 예외를 처리하는 코드가 포함됩니다. 일반적인 `Exception` 대신 `IllegalArgumentException`과 같이 `catch` 블록에서 처리되는 예외 유형을 지정하는 것이 가장 좋습니다. `try` 블록에서 예외가 발생하고 적절한 처리기가 `catch` 블록에서 발견되면 예외는 처리된 것으로 간주되고 프로그램은 정상적으로 실행됩니다.")** 메커니즘이 있습니다. 코드에서 예외가 발생하면 Kotlin은 해당 예외에 적합한 핸들러를 찾습니다. 이러한 핸들러는 예외가 발생한 메서드 또는 호출하는 메서드에 위치할 수 있습니다. 적합한 핸들러를 찾아 실행하면 예외는 처리된 것으로 간주되어 프로그램이 정상적으로 실행됩니다.

`try`이 주제에서는 예외를 처리하기 위한 두 가지 키워드, 즉 . 과 `catch`. 에 대해 알아보겠습니다.

## try-catch 문

예외를 처리하기 위한 간단한 `try-catch`템플릿은 다음과 같습니다.

```kotlin
try {
    // code that may throw an exception
} catch (e: SomeException) {
    // code for handling the exception
}
```

이 `try`블록은 예외를 발생시킬 수 있는 코드를 감싸는 데 사용됩니다. 이 블록에는 메서드 호출을 포함한 모든 코드 줄이 포함될 수 있습니다.

이 `catch`블록은 지정된 유형의 예외와 그 모든 하위 유형에 대한 처리기입니다. 이 블록은 `try`블록에서 해당 유형의 예외가 발생할 때 실행됩니다.

블록 에 지정된 유형은 `catch`예외여야 합니다.

제시된 템플릿에서 `catch`블록은 해당 유형의 예외 `Exception`와 해당 유형에서 파생된 모든 유형을 처리할 수 있습니다.

다음 예제는 `try`및 를 사용한 실행 흐름을 보여줍니다 `catch`.

```kotlin
println("Before the try-catch block") // it will be printed
try {
    println("Inside the try block before an exception") // it will be printed
    println(2 / 0) // it throws ArithmeticException
    println("Inside the try block after the exception") // it won't be printed
} catch (e: ArithmeticException) {
    println("Division by zero!") // it will be printed
}

println("After the try-catch block") // it will be printed
```

출력:

```no-highlight
Before the try-catch block
Inside the try block before an exception
Division by zero!
After the try-catch block
```

프로그램은 정상적인 실행 흐름을 중단했기 `"Inside the try block after the exception"`때문에 출력하지 않습니다. 대신 블록 내의 print 문을 실행합니다. 블록이 완료되면 프로그램은 블록으로 다시 돌아가지 않고 다음 문장(출력 ) 을 실행합니다 .`ArithmeticException``catch``catch``"After the try-catch block"``try`

문장에서 `ArithmeticException`' `Exception`또는' 으로 대체해도 프로그램의 실행 흐름은 바뀌지 않습니다. 하지만 예를 들어 '또는'으로 대체하면 해당 예외에 대한 처리기가 부적합해지고 프로그램이 실패하게 됩니다.`RuntimeException``catch``NumberFormatException`

주의하세요! 블록에 선언된 변수는 `try`블록 내부에서만 사용할 수 있습니다. 블록 외부나 블록 내부에서는 사용할 수 없습니다 `catch`.

블록 을 실행한 결과 표현식 `try`에서 예상하지 못한 예외가 발생 하면 `catch`프로그램은 모든 예방 조치에도 불구하고 실패합니다.

## 예외에 대한 정보 얻기

블록 에서 예외가 발생하면 `catch`해당 예외에 대한 정보를 얻을 수 있습니다. 이를 위해 다음을 사용합니다 `message`.

```kotlin
try {
    val d = (2 / 0).toDouble()
} catch (e: Exception) {
    println(e.message)
}
```

이 코드는 다음을 인쇄합니다.

```kotlin
/ by zero
```

## 여러 예외 포착

모든 유형의 예외에 대해 단일 처리기를 사용하는 것은 항상 가능합니다.

```kotlin
try {
    // code that may throw exceptions
} catch (e: Exception) {
    println("Something goes wrong")
}
```

물론, 이 접근 방식에서는 발생한 예외 유형에 따라 다른 작업을 수행할 수 없습니다. 다행히 Kotlin은 같은 `try`블록 내에서 여러 핸들러를 사용할 수 있도록 지원합니다.

```kotlin
try {
    // code that throws exceptions
} catch (e: IOException) {
    // handling the IOException and its subtypes   
} catch (e: Exception) {
    // handling the Exception and its subtypes
}
```

`catch`필요한 만큼 블록을 추가할 수 있습니다 . `try`블록에서 예외가 발생하면 런타임 시스템은 `catch`예외 유형에 따라 가장 적합한 첫 번째 블록을 결정합니다. 일치는 위에서 아래로 진행됩니다.

기본 타입을 가진 블록 `catch`은 하위 타입을 가진 모든 블록 아래에 작성해야 합니다. 즉, 더 일반적인 핸들러(예 `IOException`: )보다 더 특화된 핸들러를 먼저 작성해야 합니다 `Exception`. 그렇지 않으면 하위 타입을 가진 블록은 무시됩니다.

## 예외를 어디서 어떻게 처리해야 하나요?

기술적으로 예외는 발생한 메서드 또는 호출 메서드에서 처리될 수 있습니다. 예외를 처리하는 가장 좋은 방법은 해당 예외를 기반으로 올바른 결정을 내릴 수 있는 충분한 정보를 가진 메서드에서 예외를 처리하는 것입니다.

그렇다면 모든 가능한 경우를 포함하고 항상 적절한 일반적인 예외가 있는데 왜 특정 유형의 예외만 버려야 할까요 `Exception`? 몇 주 후에 동료나 심지어 여러분 자신도 코드에서 무슨 일이 일어나고 있는지 정확히 알지 못할 수도 있다는 점을 명심하세요. 가능한 한 많은 정보를 제공하는 것이 가장 좋습니다. 그러면 예외 처리가 훨씬 수월해질 것입니다.

항상 예외 이벤트에 가장 적합한 예외 유형을 찾으세요. 예를 들어, `NumberFormatException`단순히 . 대신 . 을 throw하세요 `Exception`.

## 결론

요약하자면, 이 `try-catch` [문장은](https://hyperskill.org/learn/step/10622 "Kotlin에서 명령문은 텍스트를 인쇄하거나 변수에 값을 할당하는 것과 같이 실행할 단일 명령입니다. | 계산 결과로 단일 값을 생성하는 표현식과 달리 명령문은 프로그램 상태를 변경하는 것과 같은 부작용이 있는 독립형 명령입니다. 명령문의 결과는 프로그램에서 사용되지 않지만 표현식의 결과는 종종 사용됩니다. 예를 들어, `val x = 2 * 2` 명령문에서 `2 * 2` 표현식이 평가되고 그 결과가 `x` 변수에 할당됩니다. 그러나 명령문 자체의 결과는 프로그램에서 사용되지 않습니다. 반대로 `println(2 * 2)`라고 작성하면 `2 * 2` 표현식이 평가되고 그 결과가 `println` 함수에 직접 전달되어 결과가 인쇄됩니다. 명령문은 표현식이 될 수 있지만 모든 표현식이 명령문인 것은 아니라는 점에 유의하는 것이 중요합니다. 예를 들어, `2 * 2`는 표현식이지만 프로그램의 상태를 변경하지 않으므로 명령문이 아닙니다.") 예외 처리에 사용됩니다. `try`블록에는 예외를 발생시킬 수 있는 동작들이 포함되어 있습니다. `catch`예외가 발생하면 블록이 실행됩니다. 이제 연습해 봅시다!
