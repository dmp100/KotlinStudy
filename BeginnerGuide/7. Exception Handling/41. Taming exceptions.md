

```cardlink
url: https://hyperskill.org/learn/step/7601
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


여러분은 이미 예외가 무엇이고 어떻게 발생하여 프로그램을 중단시키는지 알고 계실 겁니다. 또한, 예외가 발생한 위치를 파악하는 방법도 알고 계실 겁니다. 이 글에서는 다른 유형의 예외와 이를 방지하는 방법을 알아보겠습니다. 나아가, 직접 예외를 생성하는 방법도 알아보겠습니다.

## 또 다른 유형의 예외

다음 코드를 살펴보세요.

```kotlin
fun calculateSpentMoney(total: Int, itemPrice: Int): Int {
    val amountToBuy = total / itemPrice
    return amountToBuy * itemPrice
}
```

`itemPrice`이 함수는 다음과 같은 상황에서 사용할 수 있습니다. 가격이 이고 돈이 있는 햄버거를 최대 수량만큼 구매했을 때 얼마를 지출할지 계산하고 싶다고 가정해 보겠습니다 `total`. 이 함수는 어떻게 작동할까요? 예를 들어 `itemPrice`이고 에 `$2`있다고 가정해 보겠습니다 . 함수는 를 반환합니다 .`$37``total``36`

여기서 문제가 있다고 생각하지 않으세요? 저희는 알아요. 만약 아이템이 공짜라면 어떨까요? 초콜릿 공장에서 맛볼 수 있는 사탕 같은 거요? 저희는 확실히 많이 사서 한 푼도 안 쓰고 있어요!

하지만 이 함수는 아직 무료로 사용할 준비가 되지 않았습니다... 이 함수를 like라고 호출하면 메시지 와 함께 `calculateSpentMoney(37, 0)`이 생성됩니다 .`ArithmeticException``/ by zero`

## 수정하는 방법

걱정할 필요 없습니다. 많은 경우 예외를 방지할 수 있습니다. 어떤 경우가 문제가 되는지 판단하기만 하면 됩니다. 예를 들어, 항목이 비어 있을 때 함수는 를 반환해야 `0`하지만, 충돌이 발생합니다.

사실, 우리는 방금 특별한 사례를 공식화했습니다. 이제 간단히 조건을 추가하여 이 상황을 처리해 보겠습니다.

```kotlin
fun calculateSpentMoney(total: Int, itemPrice: Int): Int {
    if (itemPrice == 0) {
        return 0
    }
    val amountToBuy = total / itemPrice
    return amountToBuy * itemPrice
}
```

이는 코드 충돌을 예방하는 방법의 예입니다. 우리는 예외 상황을 예측했습니다.

기억하세요: 많은 경우 조건을 사용하여 예외를 피할 수 있습니다. 따라서 프로그램에서 특수한 경우를 고려하고 확인 사항을 추가하세요.

## 예외 발생

함수의 입력 데이터에서 또 하나의 특수한 경우를 알고 있습니다. 바로 음수입니다. 함수는 크래시되지 않지만, 결과는 쓸모가 없습니다.

특별한 경우를 나열해 보겠습니다.

- 우리는 주머니에 _음수의 현금을_ 가질 수 없습니다 .
    
- _품목의 가격_ 이 _음수_ 이면 모든 품목을 가져올 수 있지만 품목의 개수는 알 수 없습니다.
    

두 경우 모두 함수가 반환할 수 있는 합리적인 결과는 없습니다. 예를 들어, 를 반환하면 `0`오류가 조용히 억제됩니다.

그래서 우리가 직접 예외를 생성하는 겁니다! 코틀린에는 이를 위한 키워드가 있습니다 `throw`. 키워드 뒤에 예외 객체를 추가하기만 하면 됩니다.

```kotlin
fun calculateSpentMoney(total: Int, itemPrice: Int): Int {
    if (total < 0) {
        throw Exception("Total can't be negative")
    }
    if (itemPrice < 0) {
        throw Exception("Item price can't be negative")
    }
    if (itemPrice == 0) {
        return 0
    }
    val amountToBuy = total / itemPrice
    return amountToBuy * itemPrice
}
```

예를 들어, 누군가가 이 함수를 다음과 같이 호출하면 `calculateSpentMoney(-10, 4)`첫 번째 조건이 참이고 프로그램은 제공된 예외 메시지와 함께 충돌합니다.

**왜 Exception(...)을** 작성해야 할까요 ? 정답입니다! 사실 모든 예외는 **계층 구조 트리** 에 위치합니다 . 따라서 **Exception은**`ArithmeticException` 구체적인 내용 없이 공통적인 유형을 나타냅니다. Exception 과 Exception 처럼 더 구체적인 유형도 있습니다 `NumberFormatException`. 이러한 유형은 정확히 무슨 일이 발생했는지 더 잘 정의하는 데 도움이 됩니다. 하지만 이러한 유형의 예외는 이 주제의 범위를 벗어납니다. 계층 구조 개요에 대해서는 다른 주제에서 다루겠습니다. 그러면 다른 예외 유형에 대해 더 자세히 알아보실 수 있습니다.

예외는 객체이므로 변수에 저장할 수 있다는 점을 잊지 마세요 `val countError = Exception("Number is too big")`. 이렇게 하면 프로그램이 중단되지 않습니다. 와 같은 작업을 할 때만 프로그램이 중단됩니다 `throw countError`.

예외를 발생시킬 때 [반환 유형은](https://hyperskill.org/learn/step/7601 "코틀린에서 반환 타입은 함수가 반환하는 값의 타입입니다. | 함수가 값을 반환하지 않으면 반환 타입은 `Unit`으로 표시되며, 이는 코틀린에서 알려진 모든 타입의 하위 타입입니다. 이는 분모가 0인 백분율을 계산하는 경우처럼 함수가 값을 반환할 수 없는 상황에서 유용합니다. 이러한 경우 `Nothing`을 반환하면 함수가 null이나 다른 임의의 값을 반환하는 대신 값을 반환하지 않음을 나타냅니다.") [_Nothing_](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html) 이라는 점을 기억하세요 .

```kotlin
fun makeAnException(): Nothing {
    throw Exception("I'm an exception!")
}
```

## 결론

이제 다른 유형의 예외와 직접 생성하는 방법을 알게 되었습니다. 결론적으로, 여기서 중요한 점은 예외 발생을 피할 수 있는 상황과 수동으로 예외를 생성하는 것이 더 나은 상황이 있다는 것입니다.
