
```cardlink
url: https://hyperskill.org/learn/step/11809
title: "Hyperskill"
host: hyperskill.org
favicon: https://hs.azureedge.net/static/hyperskill.org/favicons/favicon.ico
image: https://hyperskill.org/static/hyperskill-hypercover.png
```


이미 예외를 잡는 데 꽤 능숙하시죠. 이 글에서는 Kotlin에서 예외를 처리하는 데 도움이 되는 몇 가지 기능을 더 살펴보겠습니다.

## 마지막으로 블록

아시다시피, 코틀린에서는 이 `try-catch` [문장을 사용하여](https://hyperskill.org/learn/step/11809 "Kotlin에서 명령문은 텍스트를 인쇄하거나 변수에 값을 할당하는 것과 같이 실행할 단일 명령입니다. | 계산 결과로 단일 값을 생성하는 표현식과 달리 명령문은 프로그램 상태를 변경하는 것과 같은 부작용이 있는 독립형 명령입니다. 명령문의 결과는 프로그램에서 사용되지 않지만 표현식의 결과는 종종 사용됩니다. 예를 들어, `val x = 2 * 2` 명령문에서 `2 * 2` 표현식이 평가되고 그 결과가 `x` 변수에 할당됩니다. 그러나 명령문 자체의 결과는 프로그램에서 사용되지 않습니다. 반대로 `println(2 * 2)`라고 작성하면 `2 * 2` 표현식이 평가되고 그 결과가 `println` 함수에 직접 전달되어 결과가 인쇄됩니다. 명령문은 표현식이 될 수 있지만 모든 표현식이 명령문인 것은 아니라는 점에 유의하는 것이 중요합니다. 예를 들어, `2 * 2`는 표현식이지만 프로그램의 상태를 변경하지 않으므로 명령문이 아닙니다.") [예외를 처리](https://hyperskill.org/learn/step/11809 "코틀린에서 예외 처리란 프로그램 실행 중 예외를 처리하고 대응하는 과정을 의미합니다. | 이 작업은 `try` 및 `catch` 키워드를 사용하여 수행됩니다. `try` 블록에는 예외를 발생시킬 수 있는 코드가 포함되어 있고, `catch` 블록에는 예외 발생 시 수행할 작업이 포함되어 있습니다. `try` 블록에서 예외가 발생하면 런타임 시스템은 처음부터 시작하여 해당 예외를 처리할 첫 번째 적합한 `catch` 블록을 결정합니다. 예외를 기반으로 올바른 결정을 내릴 수 있는 충분한 정보가 있는 메서드에서 예외를 처리하는 것이 가장 좋습니다.") 할 수 있습니다 . 사실, 이라는 또 다른 블록이 있습니다 `finally`. 이 블록에 있는 모든 문장은 블록에서 예외가 발생하든 `try`그렇지 않든 항상 실행됩니다.

```kotlin
try {
    // code that may throw an exception
}
catch (e: Exception) {
    // exception handler
}
finally {
    // code is always executed
}
```

위 예에서 `finally`블록은 블록 다음에 실행됩니다 `catch`. 예외 발생 여부와 관계없이 마무리 작업을 수행해야 하는 상황에서 유용할 것입니다 `finally`. 예를 들어, 파일 작업 중 예외가 발생할 수 있습니다. 이 경우, 해당 `finally`명령문에서 해당 파일을 닫는 코드를 작성할 수 있습니다.

## 세 가지 마법의 단어

아래 예를 주의 깊게 살펴보세요. 이는 명령문의 실행 순서를 보여줍니다 `try-catch-finally`.

```kotlin
try {
    println("Inside the try block")
    println(2 / 0) // throws ArithmeticException
}
catch (e: Exception) {
    println("Inside the catch block")
}
finally {
    println("Inside the finally block")
}

println("After the try-catch-finally block")
```

출력은 다음과 같습니다.

```no-highlight
Inside the try block
Inside the catch block
Inside the finally block
After the try-catch-finally block
```

를 throw하는 줄을 제거하더라도 `ArithmeticException`블록 은 블록 `finally`이후에도 실행됩니다 `try`.

```no-highlight
Inside the try block
Inside the finally block
After the try-catch-finally block
```

`finally`혹시 궁금한 점이 있으실지도 모르겠습니다. 뒤에 코드를 작성하면 되는데, 왜 블록이 필요한 걸까요 `try-catch`? 더 잘 이해하시려면 다음 예시를 살펴보세요.

```kotlin
fun main() {
    try {
        val a = 0/0 // throws ArithmeticException
    }
    finally {
        println("End of the try block") // will be executed
    }
    println("End of the program") // will not be printed
}
```

예외가 발생한 후, 뒤에 있는 "프로그램 종료"를 출력하는 줄은 `try-catch`실행되지 않습니다. 반면, [finally 블록은](https://hyperskill.org/learn/step/11809 "Kotlin에서 finally 블록은 try-catch-finally 문의 일부로, 예외 발생 여부와 관계없이 실행되어야 하는 정리 코드를 감싸는 데 사용됩니다. | 예를 들어, 파일 작업 시 finally 블록에 파일을 닫는 코드를 작성하면 예외 발생 여부와 관계없이 파일이 닫히도록 할 수 있습니다. finally 블록을 생략하면 정리 코드를 try 블록 뒤에 작성해야 하지만, 문제는 예외가 발생한 후에는 try 블록 뒤의 코드가 실행되지 않는다는 것입니다.") **항상** 실행 됩니다 .

`finally`블록 내에서 예외가 발생하더라도 블록은 실행된다는 점에 유의하세요 `catch`.

## 블록 생략

블록 없이도 `try`and 를 쓸 수 있습니다 .`finally``catch`

```kotlin
try {
    // code that may throw an exception
} 
finally {   
    // code will always be executed
}
```

이 템플릿에서는 `finally`블록이 블록 바로 뒤에 실행됩니다 `try`.

따라서 코드는 `catch`블록을 여러 개 포함하거나 아예 포함하지 않을 수 있으며, `finally`블록은 생략할 수 있습니다. 그러나 **적어도 하나의** `catch` or `finally`블록이 있어야 합니다. 즉 `try`, 를 사용하여 예외를 처리할 때는 적어도 하나의 다른 블록, `catch`즉 or 블록을 추가해야 합니다 `finally`. 그렇지 않으면 해당 명령문은 작동하지 않습니다.

## Try는 표현입니다

Java 및 다른 여러 언어와 달리 Kotlin에서는 [표현식을](https://hyperskill.org/learn/step/11809 "코틀린에서 표현식은 값으로 평가되는 코드 조각입니다. | 표현식은 간단한 리터럴 값, 변수, 함수 호출 또는 연산자나 다른 언어 구문을 사용하여 이러한 요소들을 더 복잡하게 조합한 것일 수 있습니다. 표현식은 함수에서 값을 계산하고 반환하고, 변수에 값을 할당하고, 조건문에서 계산이나 연산을 수행하는 데 사용됩니다. 예를 들어, 2 \* 2는 표현식이며 단일 값을 생성합니다.")`try` 사용할 수 있습니다 . 즉, 반환 값이 있을 수 있습니다.[](https://hyperskill.org/learn/step/11809 "코틀린에서 표현식은 값으로 평가되는 코드 조각입니다. | 표현식은 간단한 리터럴 값, 변수, 함수 호출 또는 연산자나 다른 언어 구문을 사용하여 이러한 요소들을 더 복잡하게 조합한 것일 수 있습니다. 표현식은 함수에서 값을 계산하고 반환하고, 변수에 값을 할당하고, 조건문에서 계산이나 연산을 수행하는 데 사용됩니다. 예를 들어, 2 \* 2는 표현식이며 단일 값을 생성합니다.")

```kotlin
val number: Int = try { "abc".toInt() } catch (e: NumberFormatException) { 0 }
println(number) // 0
```

블록 에서 `try`우리는 변수에 "abc" 값을 할당하려고 합니다 `number`.

문자열 "abc"를 해당 `Int`유형으로 변환하려고 하면 오류가 `NumberFormatException`발생합니다. 그런 다음 `catch`블록이 실행되어 `number`변수가 값을 가져옵니다.0.

표현식 의 반환 값 `try`은 블록의 마지막 표현식 `try`이거나 블록의 마지막 표현식 입니다 `catch`. 블록의 내용은 `finally`표현식의 결과에 영향을 미치지 않습니다.

```kotlin
val number: Int = try { "2a".toInt() } catch (e: NumberFormatException) { 0 }
finally { println("Inside the finally block") }
println(number)
```

출력은 다음과 같습니다.

```no-highlight
Inside the finally block
0
```

또 다른 유용한 기법은 호출자에게 예외를 다시 던지는 것입니다. 예외를 던질 수 있는 함수를 호출하는 코드 조각에 예외 처리 방법을 추가해야 합니다. 다음은 표현식 스타일을 사용하여 이를 수행하는 방법의 예입니다 `try`.

```kotlin
fun test() {
    val result = try {
        countSomething()
    } catch (e: ArithmeticException) {
        throw IllegalStateException(e) // do not forget to deal with it
    }

    // Working with result
}


try {
    test()
} catch (e: IllegalStateException) {
    ...
}
```

## 관용구

`try-catch`Kotlin에서 블록을 표현식으로 사용하는 것은 예외를 처리하는 [관용적인 방법](https://kotlinlang.org/docs/idioms.html#try-catch-expression) 입니다 . 결과를 즉시 얻을 수 있어 매우 편리합니다. 이 방법을 좀 더 직접적인 방법과 비교해 보세요.

```kotlin
val string = "abc"
val number = try {
    string.toInt()
} catch (e: NumberFormatException) {
    -1
}

...

val string = "abc"
var number = 0 // try to avoid var if possible
try {
    number = string.toInt()
} catch (e: NumberFormatException) {
    number = -1
}
```

## 결론

이제 예외가 어떻게 처리되든 상관없이 실행되는 블록을 `try-catch-finally`추가하여 전체 명령문을 사용하는 방법을 알았습니다 . <code> 또는 </code>를 사용하여 예외를 처리할 때 <code> 또는</code>를 건너뛸 수 있지만 , 두 가지를 동시에 생략할 수는 없습니다. 표현식으로 코드에 문법적 편의를 추가할 수도 있습니다.`finally``catch``finally``try``try-catch-finally`